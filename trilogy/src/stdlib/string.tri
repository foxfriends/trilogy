import "trilogy:core" as core
import "trilogy:array" as array

export is_empty, chars, join, length, slice, drop, take, skip, starts_with, replace, replace_all, chomp, trim, trim_start, trim_end, trim_start_satisfies, trim_end_satisfies, trim_satisfies, collect, split

func is_empty "" = true
func is_empty _ = false

test "string is_empty" {
  assert (is_empty "")
  assert !(is_empty "hello")
}

func chars str and typeof 'string = core::to_array str

test "string chars" {
  assert chars "hello" == ['h', 'e', 'l', 'l', 'o']
  assert chars "" == []
}

func join _ [] = ""
func join _ [a] = "${a}"
func join sep [a, ..strs] = "${a}${sep}${join sep strs}"

test "string join" {
  assert join " " ["hello", "there", "world"] == "hello there world"
  assert join "" ["hello", "there", "world"] == "hellothereworld"
  assert join 'x' ["hello", "there", "world"] == "helloxtherexworld"
  assert join 5 [1, 2, 3] == "15253"
}

func length str and typeof 'string = core::length str

test "string length" {
  assert length "hello" == 5
  assert length "" == 0
}

func slice i fin (str and typeof 'string) = core::slice i fin str

test "string slice" {
  assert slice 0 3 "123" == "123"
  assert slice 1 2 "123" == "2"
  assert slice 1 1 "123" == ""
  assert slice 1 3 "123" == "23"
  assert with (slice (-1) 2 "123"; false) { when 'arg cancel true }
  assert with (slice 2 1 "123"; false) { when 'arg cancel true }
  assert with (slice 0 5 "123"; false) { when 'mia cancel true }
  assert with (slice 5 5 "123"; false) { when 'mia cancel true }
}

func take n (str and typeof 'string) =
  if n <= length str
    then slice 0 n str
    else slice 0 (length str) str

test "string take" {
  assert take 0 "123" == ""
  assert take 1 "123" == "1"
  assert take 2 "123" == "12"
  assert take 3 "123" == "123"
  assert take 12 "123" == "123"
  assert with (take (-1) "123"; false) { when 'arg cancel true }
}

func skip n (str and typeof 'string) =
  if n < length str
    then slice n (length str) str
    else ""

test "string skip" {
  assert skip 0 "123" == "123"
  assert skip 1 "123" == "23"
  assert skip 2 "123" == "3"
  assert skip 3 "123" == ""
  assert skip 12 "123" == ""
  assert with (skip (-1) "123"; false) { when 'arg cancel true }
}

func drop n (str and typeof 'string) =
  if n < 0 then yield 'arg
  else if n >= length str then ""
  else slice 0 (length str - n) str

test "string drop" {
  assert drop 0 "123" == "123"
  assert drop 1 "123" == "12"
  assert drop 2 "123" == "1"
  assert drop 3 "123" == ""
  assert drop 12 "123" == ""
  assert with (drop (-1) "123"; false) { when 'arg cancel true }
}

func starts_with prefix string = take (length prefix) string == prefix

test "string starts_with" {
  assert starts_with "" ""
  assert starts_with "" "hello"
  assert starts_with "he" "hello"
  assert starts_with "hello" "hello"
  assert !(starts_with "be" "hello")
  assert !(starts_with "el" "hello")
  assert !(starts_with "hello" "he")
}

func replace "" _ _ = yield 'arg
func replace _ _ "" = ""
func replace original replacement string =
  if length original > length string
    then string
  else if starts_with original string
    then replacement <> slice (length original) (length string) string
  else "${string.0}" <> (replace original replacement <| slice 1 (length string) string)

test "string replace" {
  assert replace "h" "y" "hello" == "yello"
  assert replace "l" "n" "hello" == "henlo"
  assert replace "hel" "y" "hello" == "ylo"
  assert replace "lo" "mi" "hello" == "helmi"
  assert replace "elt" "mo" "hello" == "hello"
  assert replace "a" "b" "" == ""
}

func replace_all "" _ _ = yield 'arg
func replace_all _ _ "" = ""
func replace_all original replacement string =
  if length original > length string
    then string
  else if starts_with original string
    then replacement <> (replace_all original replacement <| slice (length original) (length string) string)
  else "${string.0}" <> (replace_all original replacement <| slice 1 (length string) string)

test "string replace_all" {
  assert replace_all "h" "y" "hello" == "yello"
  assert replace_all "l" "n" "hello" == "henno"
  assert replace_all "hel" "y" "hello" == "ylo"
  assert replace_all "lo" "mi" "hello" == "helmi"
  assert replace_all "elt" "mo" "hello" == "hello"
  assert replace_all "a" "b" "" == ""
}

func chomp str <> "\n" = str
func chomp str = str

test "string chomp" {
  assert chomp "hello\n" == "hello"
  assert chomp "hello\n\n" == "hello\n"
  assert chomp "hello" == "hello"
}

func trim_start_satisfies_ predicate [] = []
func trim_start_satisfies_ predicate ([ch, ..rest] and str) =
  if predicate ch
    then trim_start_satisfies_ predicate rest
    else str
func trim_end_satisfies_ predicate str = array::reverse <| trim_start_satisfies_ predicate <| array::reverse str

func trim_satisfies predicate str = str
  |> chars
  |> trim_start_satisfies_ predicate
  |> trim_end_satisfies_ predicate
  |> join ""
func trim_start_satisfies predicate str = join "" <| trim_start_satisfies_ predicate <| chars str
func trim_end_satisfies predicate str = join "" <| trim_end_satisfies_ predicate <| chars str

func is_whitespace char = char == ' ' || char == '\n' || char == '\t'

func trim str = trim_satisfies is_whitespace str
func trim_end str = trim_end_satisfies is_whitespace str
func trim_start str = trim_start_satisfies is_whitespace str

test "string trim" {
  assert trim "  hello  " == "hello"
  assert trim "\n\t  hello \t\n " == "hello"
  assert trim_start "\n\t  hello \t\n " == "hello \t\n "
  assert trim_end "\n\t  hello \t\n " == "\n\t  hello"
}

func split_ pos sep string =
  if pos >= length string
    then [string]
  else if starts_with sep <| skip pos string
    then [take pos string, ..split_ 0 sep <| skip (pos + length sep) string]
  else
    split_ (pos + 1) sep string
func split "" string = chars string
func split sep string = split_ 0 sep string

test "string split" {
  assert split " " "hello there world" == ["hello", "there", "world"]
  assert split " " "hello  there" == ["hello", "", "there"]
  assert split "ll" "helllo worlld" == ["he", "lo wor", "d"]
}

func collect iterator =
  let mut str = "",
  with (iterator!(); str) {
    when 'next(val) then {
      str <>= core::to_string val
      become unit
    }
  }

test "string collect" {
  let string_iter = do() {
    yield 'next("hello")
    yield 'next(" ")
    yield 'next("world")
  }
  assert collect string_iter == "hello world"

  let mixed_iter = do() {
    yield 'next(true)
    yield 'next(' ')
    yield 'next(3)
  }
  assert collect mixed_iter == "true 3"
}
