import "trilogy:core" as core
import "trilogy:iterator" as it

export numer, denom, is_natural, is_whole, is_integer, is_real, is_imaginary, is_complex, from_digit, from_hex_digit, abs, re, im, conj, swap, sign, ceil, floor, trunc, from_digits_base, parse_from_hex_digits, parse_from_digits

func numer num and typeof 'number = core::numer!(num)

test "number numer" {
  assert numer 1 == 1
  assert numer 3/2 == 3
  assert numer 4/2 == 2
  assert numer (3+1i)== 3
  assert numer (-5/2) == -5
  assert numer (3/2 + 1/4i) == 3
}

func denom num and typeof 'number = core::denom!(num)

test "number denom" {
  assert denom 1 == 1
  assert denom 3/2 == 2
  assert denom 4/2 == 1
  assert denom (3 + 1i) == 1
  assert denom (-5/2) == 2
  assert denom (3/2 + 1/4i) == 2
}

func is_natural num = im num == 0 && denom num == 1 && numer num >= 1

test "number is_natural" {
  assert is_natural 3
  assert !(is_natural 0)
  assert !(is_natural (-1))
  assert !(is_natural 1/2)
  assert !(is_natural 1i)
  assert !(is_natural (3 + 1i))
}

func is_whole num = im num == 0 && denom num == 1 && numer num >= 0

test "number is_whole" {
  assert is_whole 3
  assert is_whole 0
  assert !(is_whole 1/2)
  assert !(is_whole (-1))
  assert !(is_whole 1i)
  assert !(is_whole (3 + 1i))
}

func is_integer num = im num == 0 && denom num == 1

test "number is_integer" {
  assert is_integer 3
  assert is_integer 0
  assert is_integer (-1)
  assert !(is_integer 1/2)
  assert !(is_integer 1i)
  assert !(is_integer (3 + 1i))
}

func is_real num = im num == 0

test "number is_integer" {
  assert is_real 3
  assert is_real 0
  assert is_real (-1)
  assert is_real 1/2
  assert !(is_real 1i)
  assert !(is_real (3 + 1i))
}

func is_imaginary num = re num == 0 && im num != 0

test "number is_integer" {
  assert !(is_imaginary 3)
  assert !(is_imaginary 0)
  assert !(is_imaginary (-1))
  assert !(is_imaginary 1/2)
  assert is_imaginary 1i
  assert !(is_imaginary (3 + 1i))
}

func is_complex num = re num != 0 && im num != 0

test "number is_integer" {
  assert !(is_complex 3)
  assert !(is_complex 0)
  assert !(is_complex (-1))
  assert !(is_complex 1/2)
  assert !(is_complex 1i)
  assert (is_complex (3 + 1i))
}

func re num and typeof 'number = core::re!(num)

test "number re" {
  assert re (3 + 1i) == 3
  assert re (-3 - 1i) == -3
}

func im num and typeof 'number = core::im!(num)

test "number im" {
  assert im (3 + 1i) == 1
  assert im (-3 - 1i) == -1
}

func conj num and typeof 'number = re num - (1i * im num)

test "number conj" {
  assert conj (3 + 1i) == 3 - 1i
  assert conj (-3 - 1i) == -3 + 1i
}

func swap num and typeof 'number = conj num * 1i

test "number swap" {
  assert swap (3 + 1i) == 1 + 3i
  assert swap (-3 - 1i) == -1 - 3i
}

func from_digit '9' = 9
func from_digit '8' = 8
func from_digit '7' = 7
func from_digit '6' = 6
func from_digit '5' = 5
func from_digit '4' = 4
func from_digit '3' = 3
func from_digit '2' = 2
func from_digit '1' = 1
func from_digit '0' = 0

func from_hex_digit 'a' = 10
func from_hex_digit 'A' = 10
func from_hex_digit 'b' = 11
func from_hex_digit 'B' = 11
func from_hex_digit 'c' = 12
func from_hex_digit 'C' = 12
func from_hex_digit 'd' = 13
func from_hex_digit 'D' = 13
func from_hex_digit 'e' = 14
func from_hex_digit 'E' = 14
func from_hex_digit 'f' = 15
func from_hex_digit 'F' = 15
func from_hex_digit n = from_digit n

func from_digits_base base digits and typeof 'array =
  digits
  |> it::from
  |> from_digits_base base
func from_digits_base base digits = digits
  |> it::fold (fn d a. a * base + d) 0

test "number parse_from_digits" {
  assert from_digits_base 10 [1, 2, 3, 4, 5, 6] == 123456
  assert from_digits_base 8 (it::from [1, 2, 3, 4, 5, 6]) == 0o123456
  assert from_digits_base 2 [] == 0
}

func parse_from_digits digits = digits
  |> it::from
  |> it::map from_digit
  |> from_digits_base 10

test "number parse_from_digits" {
  assert parse_from_digits "123456" == 123456
  assert parse_from_digits ['1', '2', '3', '4', '5'] == 12345
  assert parse_from_digits "" == 0
}

func parse_from_hex_digits digits = digits
  |> it::from
  |> it::map from_hex_digit
  |> from_digits_base 16

test "number parse_from_hex_digits" {
  assert parse_from_hex_digits "ff6600" == 0xff6600
  assert parse_from_hex_digits ['f', 'a', 'b', 'c'] == 0xfabc
  assert parse_from_hex_digits "" == 0
}

func abs n = if n >= 0 then n else -n

test "number abs" {
  assert abs (-3) == 3
  assert abs 3 == 3
  assert abs 0 == 0
}

func sign a =
  match a {
    case 0 then 0
    case n if n < 0 then -1
    else 1
  }

test "number sign" {
  assert sign 5 == 1
  assert sign 0 == 0
  assert sign (-5) == -1
}

func trunc_ a = if denom a == 1 then a else numer a // denom a
func trunc a = trunc_ (re a) + 1i * trunc_ (im a)

test "number trunc" {
  assert trunc 5 == 5
  assert trunc 0 == 0
  assert trunc (-5) == -5
  assert trunc (-5/2) == -2
  assert trunc (5/2) == 2
  assert trunc (5/2 + 5/2i) == 2 + 2i
  assert trunc (-5/2 - 5/2i) == -2 - 2i
}

func floor_ a = if denom a == 1 then a else if a > 0 then trunc_ a else trunc_ a - 1
func floor a = floor_ (re a) + 1i * floor_ (im a)

test "number floor" {
  assert floor 5 == 5
  assert floor 0 == 0
  assert floor (-5) == -5
  assert floor (-5/2) == -3
  assert floor (5/2) == 2
  assert floor (5/2 + 5/2i) == 2 + 2i
  assert floor (-5/2 - 5/2i) == -3 - 3i
}

func ceil_ a = if denom a == 1 then a else if a > 0 then trunc_ a + 1 else trunc_ a
func ceil a = ceil_ (re a) + 1i * ceil_ (im a)

test "number ceil" {
  assert ceil 5 == 5
  assert ceil 0 == 0
  assert ceil (-5) == -5
  assert ceil (-5/2) == -2
  assert ceil (5/2) == 3
  assert ceil (5/2 + 5/2i) == 3 + 3i
  assert ceil (-5/2 - 5/2i) == -2 - 2i
}
