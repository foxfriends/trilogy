#! Parser combinators, inspired by Haskell's Parsec package.
#!
#! See also:
#!    https://hackage.haskell.org/package/parsec-3.1.18.0/docs/Text-Parsec-Combinator.html
import "trilogy:debug" use dbg
import "trilogy:array" as array
import "trilogy:number" as num
import "trilogy:string" as str

export apply, parse, run_parser, atomic, map, seq, option, choice, many, many_1, sep_by, sep_by_1, followed_by, prefixed_by, between, end_by, end_by_1, sep_end_by, per_line, eof, any_char, char, char_of, digit, string, integer

## Within the context of a larger parser, apply this sub parser and get its result.
func apply parser = parser!()

## Run a parser against an input string. Returns the parsed result.
##
## Note that this does not necessarily consume the entire input string.
## If this is desired, consider ensuring the provided parser ends with
## the `eof` parser.
func parse parser input = (run_parser parser input) . 'left

## Run a parser against an input string, returning the parsed result
## and the remaining portion of the string.
func run_parser parser input =
  let len = str::length input,
  let mut pos = 0,
  let result = with parser!()
    when 'eof if pos == len resume true
    when 'eof resume false
    when 'pos resume pos
    when 'reset(new_pos) then {
      pos = new_pos
      become unit
    }
    when 'next if pos < len resume 'some(input.pos)
    when 'next resume 'none
    when 'accept then {
      pos += 1
      become unit
    }
    else yield,
  result : str::slice pos len input

## Parses the parser as a single atomic unit, without consuming any of the input on failure.
func atomic parser = do() {
  let pos = yield 'pos
  return with apply parser
    when 'reject(_) and rej then {
      yield 'reset(pos)
      yield rej
    }
    else yield
}

## Transform the output value of a parser without parsing any more input.
func map f parser = do() f parser!()

## Run a list of parsers in sequence, parsing to a list of their results.
func seq parsers = do() array::map apply parsers

## Attempt a parser, returning 'some(result) if it succeeds. If it fails,
## returns 'none without consuming any input.
func option parser = do()
  with 'some(apply <| atomic parser)
    when 'reject(_) cancel 'none
    else yield

## Attempt each of the list of parsers. Returns the value of the first
## parser that succeeds.
func choice [] = do() yield 'reject("choice had no options")
func choice [parser, ..rest] = do () {
  return with apply <| atomic parser
    when 'reject(err) cancel with apply <| choice rest
      when 'reject("choice had no options") then {
        yield 'reject(err)
        end
      }
      when 'reject(errs) then {
        yield 'reject("${err}, or ${errs}")
        end
      }
      else yield
    else yield
}

## Applies the parser as many times as possible, returning an array of
## the parsed results.
func many parser = do() {
  let result = with apply <| atomic parser
    when 'reject(_) then { return [] }
    else yield
  return [result, ..apply <| many parser]
}

## Applies the parser as many times as possible, but at least once, returning
## an array of the parsed results.
func many_1 parser = do() {
  let first = apply <| atomic parser
  let rest = apply <| many parser
  return [first, ..rest]
}

func sep_tail sep parser = do() {
  return match apply <| option <| prefixed_by sep parser
    case 'some(result) then [result, ..apply <| sep_tail sep parser]
    else then [] 
}

## Parses zero or more occurrences of `parser`, separated by `sep`. Returns
## an array of the parsed values of `parser`.
func sep_by sep parser = do() {
  return match apply <| option parser
    case 'some(first) then [first, ..apply <| sep_tail sep parser]
    else then []
}

## Parses one or more occurrences of `parser`, separated by `sep`. Returns
## an array of the parsed values of `parser`.
func sep_by_1 sep parser = do() {
  let first = apply <| atomic parser
  let tail = apply <| sep_tail sep parser
  return [first, ..tail]
}

## Parses `parser` followed by `follow`, returning only the result of `parser`.
func followed_by follow parser = do() {
  let result = apply parser
  apply follow
  return result
}

## Parses `prefix` followed by `parser`, returning only the result of `parser`.
func prefixed_by prefix parser = do() {
  apply prefix
  return apply parser
}

## Parses `parser` between `prefix` and `suffix`, returning only the result of `parser`.
func between prefix suffix parser = do() {
  apply prefix
  let result = apply parser
  apply suffix
  return result
}

## Parses zero or more occurrences of `parser`, separated and ended by `sep`.
## Returns an array of the parsed values of `parser`.
func end_by sep parser = do() {
  let first = match apply <| option <| followed_by sep parser
    case 'some(value) then value
    else then return []
  let tail = apply <| end_by sep parser
  return [first, ..tail]
}

## Parses one or more occurrences of `parser`, separated and ended by `sep`.
## Returns an array of the parsed values of `parser`.
func end_by_1 sep parser = do() {
  let first = apply <| atomic <| followed_by sep parser
  let tail = apply <| end_by sep parser
  return [first, ..tail]
}

func sep_end_by sep parser = do() {
  let first = match apply <| option parser
    case 'some(value) then value
    else then return []
  return match apply <| option sep
    case 'some(_) then [first, ..apply <| sep_end_by sep parser]
    else then [first]
}

## Reads one instance of `parser` per line.
func per_line parser = sep_end_by (char '\n') parser

## A parser that matches the end of input.
proc eof!() {
  if ! yield 'eof {
    yield 'reject("expected end of input")
    end
  }
}

## A parser for a single character.
func char c = do() {
  let actual = match yield 'next
    case 'some(ch) then ch
    else {
      yield 'reject("reached end of input")
      end
    }
  if c == actual {
    yield 'accept
    return c
  } else {
    yield 'reject("expected '${c}', got '${actual}'")
    end
  }
}

## A parser for a single character.
func any_char c = do() {
  match yield 'next
    case 'some(ch) {
      yield 'accept
      return c
    }
    else {
      yield 'reject("reached end of input")
      end
    }
}

## A parser for a specific sequence of characters.
func string s = s
  |> str::chars
  |> array::map char
  |> seq
  |> map (str::join "")
  |> atomic

## A parser for any single character from a string.
func char_of s = s
  |> str::chars
  |> array::map char
  |> choice

## A parser for any base-10 digit.
proc digit!() {
  return apply <| char_of "0123456789"
}

test "parsec digit" {
  assert parse digit "123" == '1'
  assert with parse digit "A"; false when 'reject(_) cancel true else cancel false
}

## Parses a base-10 integer from a string, returning the value as a number.
proc integer!() {
  let digits = apply <| many_1 digit
  return digits
    |> array::map (num::from_digit)
    |> array::fold (fn a d. 10 * a + d) 0
}

test "parsec integer" {
  assert parse integer "12345" == 12345
  assert parse integer "000300" == 300
}
