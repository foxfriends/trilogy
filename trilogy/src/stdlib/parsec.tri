#! Parser combinators, inspired by Haskell's Parsec package.
#!
#! See also:
#!    https://hackage.haskell.org/package/parsec-3.1.18.0/docs/Text-Parsec-Combinator.html
import "trilogy:debug" use dbg
import "trilogy:array" as array
import "trilogy:str" as str

export apply, parse, map, seq, option, eof, char, string

## Within the context of a larger parser, apply this sub parser and get its result.
func apply parser = parser!()

## Run a parser against an input string
func parse parser input =
  let len = str::length input,
  let mut pos = 0,
  with parser!()
    when 'eof if pos == len resume true
    when 'eof resume false
    when 'pos resume pos
    when 'reset(new_pos) then {
      pos = new_pos
      become unit
    }
    when 'next if pos < len resume input.pos
    when 'next cancel yield 'reject
    when 'accept then {
      pos += 1
      become unit
    }
    when 'reject cancel yield 'reject
    else yield

## Transform the output value of a parser without parsing any more input.
func map f parser = do() f parser!()

## Run a list of parsers in sequence, parsing to a list of their results.
func seq parsers = do() array::map apply parsers

## Attempt a parser, returning 'some(result) if it succeeds. If it fails,
## returns 'none without consuming any input.
func option parser = do() {
  let pos = yield 'pos
  return with 'some(apply parser)
    when 'reject then {
      yield 'reset(pos)
      cancel 'none
    }
    else yield
}

## A parser that matches the end of input.
proc eof!() {
  if yield 'eof {
    yield 'accept
  } else {
    yield 'reject
  }
}

## A parser for a single character.
func char c = do() {
  if c == yield 'next {
    yield 'accept
    return c
  } else {
    yield 'reject
  }
}

## A parser for a specific sequence of characters.
func string s = s
  |> str::chars
  |> array::map char
  |> seq
  |> map (str::join "")
