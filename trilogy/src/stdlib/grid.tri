import "trilogy:core" use length
import "trilogy:array" as array
import "trilogy:iterator" as it
import "trilogy:number" use im, re
import "trilogy:record" use contains_key
import "trilogy:algorithm" as algorithm

export from, adjacent, rotate_right, surrounding, x, y, coord, shortest_path_length

func x pos = re pos
func y pos = im pos
func coord x y = x + 0i1 * y

proc from!(arr and typeof 'array) {
  let mut pos = 0i0
  let mut grid = {||}
  while y pos < length arr {
    while x pos < length (arr.(y pos)) {
      grid.pos = arr.(y pos).(x pos)
      pos += 1
    }
    pos = 0i1 * (1 + y pos)
  }
  return grid
}

test "grid from" {
  let grid = from!(["123", "456", "789"])
  assert grid.0 == '1'
  assert grid.1 == '2'
  assert grid.2 == '3'
  assert grid.0i1 == '4'
  assert grid.1i1 == '5'
  assert grid.2i1 == '6'
  assert grid.0i2 == '7'
  assert grid.1i2 == '8'
  assert grid.2i2 == '9'
}

func adjacent pos = [
  pos + 1,
  pos + 0i1,
  pos + 0i1 ** 2,
  pos + 0i1 ** 3,
]

test "grid adjacent" {
  assert adjacent 0i0 == [1, 0i1, -1, -0i1]
}

func rotate_right dir = dir * 0i1

test "grid rotate_right" {
  assert rotate_right 1 == 0i1
  assert rotate_right 0i1 == -1
  assert rotate_right (-1) == -0i1
  assert rotate_right (-0i1) == 1
  assert rotate_right (-0i2) == 2
}

func surrounding pos = [
  pos - 1 - 0i1,
  pos - 1,
  pos - 1 + 0i1,
  pos - 0i1,
  pos + 0i1,
  pos + 1 - 0i1,
  pos + 1,
  pos + 1 + 0i1
]

test "grid rotate_right" {
  assert surrounding 0 == [
    -1 - 0i1,
    -1,
    -1 + 0i1,
    -0i1,
    0i1,
    1 - 0i1,
    1,
    1 + 0i1,
  ]
}

proc shortest_path_length!(grid, from, to) {
  return with algorithm::shortest_path_length!(from, to)
    when 'neighbours(from_pos) resume
      adjacent from_pos
      |> it::from
      |> it::filter (fn p. contains_key p grid)
      |> it::map (fn p. p:grid.p)
      |> array::collect
    else yield
}
