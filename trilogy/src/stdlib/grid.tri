import "trilogy:core" use length
import "trilogy:array" as array
import "trilogy:iterator" as it
import "trilogy:number" use im, re
import "trilogy:record" use contains_key
import "trilogy:algorithm" as algorithm

export from, adjacent, rotate_right, surrounding, x, y, coord, shortest_path_length

func x pos = re pos
func y pos = im pos
func coord x y = x + 1i * y

proc from!(arr and typeof 'array) {
  let mut pos = 0
  let mut grid = {||}
  while y pos < length arr {
    while x pos < length (arr.(y pos)) {
      grid.pos = arr.(y pos).(x pos)
      pos += 1
    }
    pos = 1i * (1 + y pos)
  }
  return grid
}

test "grid from" {
  let grid = from!(["123", "456", "789"])
  assert grid.0 == '1'
  assert grid.1 == '2'
  assert grid.2 == '3'
  assert grid.1i == '4'
  assert grid.(1 + 1i) == '5'
  assert grid.(2 + 1i) == '6'
  assert grid.2i == '7'
  assert grid.(1 + 2i) == '8'
  assert grid.(2 + 2i) == '9'
}

func adjacent pos = [
  pos + 1,
  pos + 1i,
  pos + 1i ** 2,
  pos + 1i ** 3,
]

test "grid adjacent" {
  assert adjacent 0 == [1, 1i, -1, -1i]
}

func rotate_right dir = dir * 1i

test "grid rotate_right" {
  assert rotate_right 1 == 1i
  assert rotate_right 1i == -1
  assert rotate_right (-1) == -1i
  assert rotate_right (-1i) == 1
  assert rotate_right (-2i) == 2
}

func surrounding pos = [
  pos - 1 - 1i,
  pos - 1,
  pos - 1 + 1i,
  pos - 1i,
  pos + 1i,
  pos + 1 - 1i,
  pos + 1,
  pos + 1 + 1i
]

test "grid rotate_right" {
  assert surrounding 0 == [
    -1 - 1i,
    -1,
    -1 + 1i,
    -1i,
    1i,
    1 - 1i,
    1,
    1 + 1i,
  ]
}

proc shortest_path_length!(grid, from, to) {
  return with algorithm::shortest_path_length!(from, to)
    when 'neighbours(from_pos) resume
      adjacent from_pos
      |> it::from
      |> it::filter (fn p. contains_key p grid)
      |> it::map (fn p. p:grid.p)
      |> array::collect
    else yield
}
