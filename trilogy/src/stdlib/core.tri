type c {
  extern "c" proc print!(value)
  export print

  extern "c" proc eprint!(value)
  export eprint

  extern "c" proc readline!()
  export readline

  extern "c" proc readchar!()
  export readchar

  extern "c" proc panic!(value)
  export panic

  extern "c" proc exit_!(value)
  export exit_

  extern "c" proc structural_eq!(lhs, rhs)
  export structural_eq

  extern "c" proc structural_neq!(lhs, rhs)
  export structural_neq

  extern "c" proc referential_eq!(lhs, rhs)
  export referential_eq

  extern "c" proc referential_neq!(lhs, rhs)
  export referential_neq

  extern "c" proc lookup_atom!(atom)
  export lookup_atom

  extern "c" proc length!(arr)
  export length

  extern "c" proc push!(arr, val)
  export push

  extern "c" proc pop!(arr)
  export pop

  extern "c" proc append!(arr, val)
  export append

  extern "c" proc contains_key!(arr, key)
  export contains_key

  extern "c" proc member_access!(container, index)
  export member_access

  extern "c" proc delete_member!(container, index)
  export delete_member

  extern "c" proc glue!(lhs, rhs)
  export glue

  extern "c" proc cons!(lhs, rhs)
  export cons

  extern "c" proc construct!(lhs, rhs)
  export construct

  extern "c" proc destruct!(val)
  export destruct

  extern "c" proc compare!(lhs, rhs)
  export compare

  extern "c" proc lt!(lhs, rhs)
  export lt

  extern "c" proc lte!(lhs, rhs)
  export lte

  extern "c" proc gt!(lhs, rhs)
  export gt

  extern "c" proc gte!(lhs, rhs)
  export gte

  extern "c" proc add!(lhs, rhs)
  export add

  extern "c" proc subtract!(lhs, rhs)
  export subtract

  extern "c" proc multiply!(lhs, rhs)
  export multiply

  extern "c" proc divide!(lhs, rhs)
  export divide

  extern "c" proc int_divide!(lhs, rhs)
  export int_divide

  extern "c" proc rem!(lhs, rhs)
  export rem

  extern "c" proc power!(lhs, rhs)
  export power

  extern "c" proc boolean_and!(lhs, rhs)
  export boolean_and

  extern "c" proc boolean_or!(lhs, rhs)
  export boolean_or

  extern "c" proc boolean_not!(lhs, rhs)
  export boolean_not

  extern "c" proc bitwise_and!(lhs, rhs)
  export bitwise_and

  extern "c" proc bitwise_or!(lhs, rhs)
  export bitwise_or

  extern "c" proc bitwise_xor!(lhs, rhs)
  export bitwise_xor

  extern "c" proc bitwise_invert!(val)
  export bitwise_invert

  extern "c" proc shift_left!(lhs, rhs)
  export shift_left

  extern "c" proc shift_left_extend!(lhs, rhs)
  export shift_left_extend

  extern "c" proc shift_left_contract!(lhs, rhs)
  export shift_left_contract

  extern "c" proc shift_right!(lhs, rhs)
  export shift_right

  extern "c" proc shift_right_extend!(lhs, rhs)
  export shift_right_extend

  extern "c" proc shift_right_contract!(lhs, rhs)
  export shift_right_contract

  extern "c" proc primitive_to_string!(val)
  export primitive_to_string

  extern "c" proc set_to_array!(val)
  export set_to_array

  extern "c" proc record_to_array!(val)
  export record_to_array

  extern "c" proc string_to_array!(val)
  export string_to_array

  extern "c" proc slice!(val, i, fin)
  export slice

  extern "c" proc re!(val)
  export re

  extern "c" proc im!(val)
  export im

  extern "c" proc numer!(val)
  export numer

  extern "c" proc denom!(val)
  export denom
}

type asm {
  extern "trilogy" proc current_backtrace!()
  extern "trilogy" proc backtrace_of!(callable)
  export current_backtrace, backtrace_of
}

slot im = c::im
export im

slot re = c::re
export re

slot numer = c::numer
export numer

slot denom = c::denom
export denom

slot print = c::print
export print

slot eprint = c::eprint
export eprint

slot readline = c::readline
export readline

slot readchar = c::readchar
export readchar

slot panic = c::panic
export panic

slot backtrace = asm::current_backtrace
export backtrace

slot backtrace_of = asm::backtrace_of
export backtrace_of

slot push = c::push
export push

slot pop = c::pop
export pop

slot delete_member = c::delete_member
export delete_member

slot append = c::append
export append

func contains_key key arr = c::contains_key!(arr, key)
export contains_key

func slice i fin (bits and typeof 'bits) =
  if i > fin || i < 0 then
    yield 'arg
  else if i > length bits || fin > length bits then
    yield 'mia
  else
    (bits <<~ i) ~>> (length bits - fin)
func slice i fin arr =
  if i > fin || i < 0 then
    yield 'arg
  else if i > length arr || fin > length arr then
    yield 'mia
  else
    c::slice!(arr, i, fin)
export slice

test "core slice" {
  assert slice 1 5 0bb10101010 == 0bb0101
  assert slice 1 5 "hello world" == "ello"
  assert slice 1 5 [1, 2, 3, 4, 5, 6, 7] == [2, 3, 4, 5]
}

export to_string
func to_string val =
  match val {
    case lhs:rhs then "${lhs}:${rhs}"
    case typeof 'struct {
      let lhs:rhs = c::destruct!(val)
      "${lhs}(${rhs})"
    }
    case typeof 'array {
      let mut str = "["
      let mut i = 0
      while i < c::length!(val) {
        str <>= "${val.i}"
        i += 1
        if i != c::length!(val) {
          str <>= ", "
        }
      }
      str <> "]"
    }
    case typeof 'set {
      let mut str = "[|"
      let mut i = 0
      let arr = c::set_to_array!(val)
      while i < c::length!(arr) {
        str <>= "${arr.i}"
        i += 1
        if i != c::length!(arr) {
          str <>= ", "
        }
      }
      str <> "|]"
    }
    case typeof 'record {
      let mut str = "{|"
      let mut i = 0
      let arr = c::record_to_array!(val)
      while i < c::length!(arr) {
        str <>= "${arr.i.'left} => ${arr.i.'right}"
        i += 1
        if i != c::length!(arr) {
          str <>= ", "
        }
      }
      str <> "|}"
    }
    else c::primitive_to_string!(val)
  }

export compose
func compose f g x = f (g x)

export rcompose
func rcompose f g x = g (f x)

export pipe
func pipe x f = f x

export rpipe
func rpipe f x = f x

func boolean_and lhs rhs = c::boolean_and!(lhs, rhs)
export boolean_and
func boolean_or lhs rhs = c::boolean_or!(lhs, rhs)
export boolean_or
func structural_eq lhs rhs = c::structural_eq!(lhs, rhs)
export structural_eq
func structural_neq lhs rhs = c::structural_neq!(lhs, rhs)
export structural_neq
func referential_eq lhs rhs = c::referential_eq!(lhs, rhs)
export referential_eq
func referential_neq lhs rhs = c::referential_neq!(lhs, rhs)
export referential_neq
func bitwise_or lhs rhs = c::bitwise_or!(lhs, rhs)
export bitwise_or
func bitwise_and lhs rhs = c::bitwise_and!(lhs, rhs)
export bitwise_and
func bitwise_xor lhs rhs = c::bitwise_xor!(lhs, rhs)
export bitwise_xor
func shift_left lhs rhs = c::shift_left!(lhs, rhs)
export shift_left
func shift_left_extend lhs rhs = c::shift_left_extend!(lhs, rhs)
export shift_left_extend
func shift_left_contract lhs rhs = c::shift_left_contract!(lhs, rhs)
export shift_left_contract
func shift_right lhs rhs = c::shift_right!(lhs, rhs)
export shift_right
func shift_right_extend lhs rhs = c::shift_right_extend!(lhs, rhs)
export shift_right_extend
func shift_right_contract lhs rhs = c::shift_right_contract!(lhs, rhs)
export shift_right_contract

func member_access (arr and typeof 'array) (index and typeof 'number) =
  if index >= 0 && index < length arr then c::member_access!(arr, index) else yield 'mia
func member_access (str and typeof 'string) (index and typeof 'number) =
  if index >= 0 && index < length str then c::member_access!(str, index) else yield 'mia
func member_access (bits and typeof 'bits) (index and typeof 'number) =
  if index >= 0 && index < length bits then c::member_access!(bits, index) else yield 'mia
func member_access (rec and typeof 'record) index =
  if c::contains_key!(rec, index) then c::member_access!(rec, index) else yield 'mia
func member_access (tup and typeof 'tuple) 'left = c::member_access!(tup, 'left)
func member_access (tup and typeof 'tuple) 'right = c::member_access!(tup, 'right)
func member_access (tup and typeof 'tuple) _ = yield 'mia
export member_access

func glue lhs rhs = c::glue!(lhs, rhs)
export glue
func lt lhs rhs = c::lt!(lhs, rhs)
export lt
func gt lhs rhs = c::gt!(lhs, rhs)
export gt
func lte lhs rhs = c::lte!(lhs, rhs)
export lte
func gte lhs rhs = c::gte!(lhs, rhs)
export gte
func add lhs rhs = c::add!(lhs, rhs)
export add
func subtract lhs rhs = c::subtract!(lhs, rhs)
export subtract
func multiply lhs rhs = c::multiply!(lhs, rhs)
export multiply
func divide lhs rhs = c::divide!(lhs, rhs)
export divide
func int_divide lhs rhs = c::int_divide!(lhs, rhs)
export int_divide
func power lhs rhs = c::power!(lhs, rhs)
export power
func rem lhs rhs = c::rem!(lhs, rhs)
export rem
func cons lhs rhs = c::cons!(lhs, rhs)
export cons
func destruct st = c::destruct!(st)
export destruct

func to_array (arr and typeof 'array) = arr
func to_array (set and typeof 'set) = c::set_to_array!(set)
func to_array (record and typeof 'record) = c::record_to_array!(record)
func to_array (string and typeof 'string) = c::string_to_array!(string)
export to_array

func length val = c::length!(val)
export length

rule between(lo, hi, lo) <- is lo < hi
rule between(lo, hi, n) <- is lo < hi and lo_2 = lo + 1 and between(lo_2, hi, n)
export between

rule elem(element, array and typeof 'array) <-
  max = length array
  and between(0, max, i)
  and element = array.i

rule elem(element, set and typeof 'set) <-
  array = c::set_to_array!(set)
  and elem(element, ^array)
rule elem(element, record and typeof 'record) <-
  array = c::record_to_array!(record)
  and elem(element, ^array)
rule elem(element, string and typeof 'string) <-
  array = c::string_to_array!(string)
  and elem(element, ^array)
export elem

import "trilogy:ansi" use red, green

proc test_main!(tests) {
  let mut successes = 0
  let mut failures = 0

  c::print!("running ${length tests} tests\n\n")

  for test_name:test_procedure in tests {
    c::print!("test ${test_name} ... ")
    with test_procedure!() {
      when 'assertion_failed(msg) then {
        c::print!(red "assertion failed")
        c::print!(": ${msg}\n")
        failures += 1
        continue unit
      }
      when eff then {
        c::print!(red "failure")
        c::print!(": unhandled effect yielded from test: ${eff}\n")
        failures += 1
        continue unit
      }
    }
    c::print!(green "ok")
    c::print!("\n")
    successes += 1
  }
  let result = if failures == 0 then green "ok" else red "failure"
  c::print!("\ntest result: ${result}. ${successes} passed; ${failures} failed\n")

  if failures != 0 {
    exit 1
  } else {
    exit 0
  }
}
export test_main

proc eprint_backtrace!(trace_frames) {
  for frame in trace_frames {
    let {| "path" => path, "name" => name, "span" => (line:col):_, .._ |} = frame
    eprint!("- ${name}\n\tat ${path} +${line}:${col}\n")
  }
}

export eprint_backtrace
