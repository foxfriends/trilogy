type c {
  extern proc print!(value)
  export print

  extern proc readline!()
  export readline

  extern proc readchar!()
  export readchar

  extern proc panic!(value)
  export panic

  extern proc trace!(value)
  export trace

  extern proc exit_!(value)
  export exit_

  extern proc structural_eq!(lhs, rhs)
  export structural_eq

  extern proc structural_neq!(lhs, rhs)
  export structural_neq

  extern proc referential_eq!(lhs, rhs)
  export referential_eq

  extern proc referential_neq!(lhs, rhs)
  export referential_neq

  extern proc lookup_atom!(atom)
  export lookup_atom

  extern proc length!(arr)
  export length

  extern proc push!(arr, val)
  export push

  extern proc append!(arr, val)
  export append

  extern proc member_access!(container, index)
  export member_access

  extern proc glue!(lhs, rhs)
  export glue

  extern proc cons!(lhs, rhs)
  export cons

  extern proc construct!(lhs, rhs)
  export construct

  extern proc destruct!(val)
  export destruct

  extern proc compare!(lhs, rhs)
  export compare

  extern proc lt!(lhs, rhs)
  export lt

  extern proc lte!(lhs, rhs)
  export lte

  extern proc gt!(lhs, rhs)
  export gt

  extern proc gte!(lhs, rhs)
  export gte

  extern proc add!(lhs, rhs)
  export add

  extern proc subtract!(lhs, rhs)
  export subtract

  extern proc multiply!(lhs, rhs)
  export multiply

  extern proc divide!(lhs, rhs)
  export divide

  extern proc int_divide!(lhs, rhs)
  export int_divide

  extern proc rem!(lhs, rhs)
  export rem

  extern proc power!(lhs, rhs)
  export power

  extern proc boolean_and!(lhs, rhs)
  export boolean_and

  extern proc boolean_or!(lhs, rhs)
  export boolean_or

  extern proc boolean_not!(lhs, rhs)
  export boolean_not

  extern proc bitwise_and!(lhs, rhs)
  export bitwise_and

  extern proc bitwise_or!(lhs, rhs)
  export bitwise_or

  extern proc bitwise_xor!(lhs, rhs)
  export bitwise_xor

  extern proc bitwise_invert!(val)
  export bitwise_invert

  extern proc shift_left!(lhs, rhs)
  export shift_left

  extern proc shift_left_extend!(lhs, rhs)
  export shift_left_extend

  extern proc shift_left_contract!(lhs, rhs)
  export shift_left_contract

  extern proc shift_right!(lhs, rhs)
  export shift_right

  extern proc shift_right_extend!(lhs, rhs)
  export shift_right_extend

  extern proc shift_right_contract!(lhs, rhs)
  export shift_right_contract

  extern proc primitive_to_string!(val)
  export primitive_to_string

  extern proc set_to_array!(val)
  export set_to_array

  extern proc record_to_array!(val)
  export record_to_array

  extern proc string_to_array!(val)
  export string_to_array

  extern proc slice!(val, i, fin)
  export slice
}

const print = c::print
export print

const readline = c::readline
export readline

const readchar = c::readchar
export readchar

const panic = c::panic
export panic

const trace = c::trace
export trace

const push = c::push
export push

const append = c::append
export append

func slice i fin arr =
  if i > fin || i < 0 then
    yield 'arg
  else if i > length arr || fin > length arr then
    yield 'mia
  else
    c::slice!(arr, i, fin)
export slice

export to_string
func to_string val = match val
  case lhs:rhs then "${lhs}:${rhs}"
  case typeof 'struct {
    let lhs:rhs = c::destruct!(val)
    "${lhs}(${rhs})"
  }
  case typeof 'array {
    let mut str = "["
    let mut i = 0
    while i < c::length!(val) {
      str <>= "${val.i}"
      i += 1
      if i != c::length!(val) {
        str <>= ", "
      }
    }
    str <> "]"
  }
  case typeof 'set {
    let mut str = "[|"
    let mut i = 0
    let arr = c::set_to_array!(val)
    while i < c::length!(arr) {
      str <>= "${arr.i}"
      i += 1
      if i != c::length!(arr) {
        str <>= ", "
      }
    }
    str <> "|]"
  }
  case typeof 'record {
    let mut str = "{|"
    let mut i = 0
    let arr = c::record_to_array!(val)
    while i < c::length!(arr) {
      str <>= "${arr.i.'left} => ${arr.i.'right}"
      i += 1
      if i != c::length!(arr) {
        str <>= ", "
      }
    }
    str <> "|}"
  }
  else then c::primitive_to_string!(val)

export compose
func compose f g x = f (g x)

export rcompose
func rcompose f g x = g (f x)

export pipe
func pipe x f = f x

export rpipe
func rpipe f x = f x

func boolean_and lhs rhs = c::boolean_and!(lhs, rhs)
export boolean_and
func boolean_or lhs rhs = c::boolean_or!(lhs, rhs)
export boolean_or
func structural_eq lhs rhs = c::structural_eq!(lhs, rhs)
export structural_eq
func structural_neq lhs rhs = c::structural_neq!(lhs, rhs)
export structural_neq
func referential_eq lhs rhs = c::referential_eq!(lhs, rhs)
export referential_eq
func referential_neq lhs rhs = c::referential_neq!(lhs, rhs)
export referential_neq
func bitwise_or lhs rhs = c::bitwise_or!(lhs, rhs)
export bitwise_or
func bitwise_and lhs rhs = c::bitwise_and!(lhs, rhs)
export bitwise_and
func bitwise_xor lhs rhs = c::bitwise_xor!(lhs, rhs)
export bitwise_xor
func shift_left lhs rhs = c::shift_left!(lhs, rhs)
export shift_left
func shift_left_extend lhs rhs = c::shift_left_extend!(lhs, rhs)
export shift_left_extend
func shift_left_contract lhs rhs = c::shift_left_contract!(lhs, rhs)
export shift_left_contract
func shift_right lhs rhs = c::shift_right!(lhs, rhs)
export shift_right
func shift_right_extend lhs rhs = c::shift_right_extend!(lhs, rhs)
export shift_right_extend
func shift_right_contract lhs rhs = c::shift_right_contract!(lhs, rhs)
export shift_right_contract

func member_access (arr and typeof 'array) (index and typeof 'number) =
  if index >= 0 && index < length arr then c::member_access!(arr, index) else yield 'mia
func member_access (str and typeof 'string) (index and typeof 'number) =
  if index >= 0 && index < length str then c::member_access!(str, index) else yield 'mia
func member_access (bits and typeof 'bits) (index and typeof 'number) =
  if index >= 0 && index < length bits then c::member_access!(bits, index) else yield 'mia
func member_access (rec and typeof 'record) index =
  if is index:_ in rec then c::member_access!(rec, index) else yield 'mia
func member_access (tup and typeof 'tuple) 'left = c::member_access!(tup, 'left)
func member_access (tup and typeof 'tuple) 'right = c::member_access!(tup, 'right)
func member_access (tup and typeof 'tuple) _ = yield 'mia
export member_access

func glue lhs rhs = c::glue!(lhs, rhs)
export glue
func lt lhs rhs = c::lt!(lhs, rhs)
export lt
func gt lhs rhs = c::gt!(lhs, rhs)
export gt
func lte lhs rhs = c::lte!(lhs, rhs)
export lte
func gte lhs rhs = c::gte!(lhs, rhs)
export gte
func add lhs rhs = c::add!(lhs, rhs)
export add
func subtract lhs rhs = c::subtract!(lhs, rhs)
export subtract
func multiply lhs rhs = c::multiply!(lhs, rhs)
export multiply
func divide lhs rhs = c::divide!(lhs, rhs)
export divide
func int_divide lhs rhs = c::int_divide!(lhs, rhs)
export int_divide
func power lhs rhs = c::power!(lhs, rhs)
export power
func rem lhs rhs = c::rem!(lhs, rhs)
export rem
func cons lhs rhs = c::cons!(lhs, rhs)
export cons
func destruct st = c::destruct!(st)
export destruct

func to_array (arr and typeof 'array) = arr
func to_array (set and typeof 'set) = c::set_to_array!(set)
func to_array (record and typeof 'record) = c::record_to_array!(record)
func to_array (string and typeof 'string) = c::string_to_array!(string)
export to_array

func length val = c::length!(val)
export length

rule elem(element, [element, .._])
rule elem(element, [_, ..rest]) <- elem(element, ^rest)
rule elem(_, []) <- end
rule elem(element, set and typeof 'set) <-
  array = c::set_to_array!(set)
  and elem(element, ^array)
rule elem(element, record and typeof 'record) <-
  array = c::record_to_array!(record)
  and elem(element, ^array)
rule elem(element, string and typeof 'string) <-
  array = c::string_to_array!(string)
  and elem(element, ^array)
export elem

import "trilogy:ansi" use red, green

proc test_main!(tests) {
  let mut successes = 0
  let mut failures = 0

  c::print!("running ${length tests} tests\n\n")

  for test_name:test_procedure in tests {
    c::print!("test ${test_name} ... ")
    with test_procedure!()
      when 'assertion_failed(msg) then {
        c::print!(red "assertion failed")
        c::print!(": ${msg}\n")
        failures += 1
        continue unit
      }
      else eff then {
        c::print!(red "failure")
        c::print!(": unhandled effect yielded from test: ${eff}\n")
        failures += 1
        continue unit
      }
    c::print!(green "ok")
    c::print!("\n")
    successes += 1
  }
  let result = if failures == 0 then green "ok" else red "failure"
  c::print!("\ntest result: ${result}. ${successes} passed; ${failures} failed\n")

  if failures != 0 {
    exit 1
  } else {
    exit 0
  }
}
export test_main
