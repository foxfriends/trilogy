import "trilogy:array" as array use collect

export run, of, forever, repeat, take, range, range_step, rangex, rangex_step, filter, map, flat_map, scan, fold, reduce, sum, count, from, any, all, enumerate, find, choose, for_each

func run it = it!()

func from arr and typeof 'array = do() { for item in arr { yield 'next(item) } }
func from set and typeof 'set = do() { for item in set { yield 'next(item) } }
func from record and typeof 'record = do() { for item in record { yield 'next(item) } }
func from string and typeof 'string = do() { for item in string { yield 'next(item) } }

test "iterator from" {
  assert collect <| from [1, 2, 3] == [1, 2, 3]

  let kvs = collect <| from {|'a => 'b, 'c => 'd|}
  assert array::length kvs == 2
  # assert is 'a:'b in kvs
  # assert is 'c:'d in kvs

  let arr = collect <| from [|1, 2, 3|]
  assert array::length arr == 3
  # assert is 1 in arr
  # assert is 2 in arr
  # assert is 3 in arr

  assert collect <| from "hello" == ['h', 'e', 'l', 'l', 'o']
}

func of val = do() {
  yield 'next(val)
}

test "iterator of" {
  assert 3 == with run <| of 3 { when 'next(val) cancel val }
  assert unit == with run <| of 3 { when 'next(3) resume 1 }
  assert collect <| of 3 == [3]
}

func forever val = do() {
  while true { yield 'next(val) }
}

func repeat n val = take n <| forever val

test "iterator repeat" {
  assert collect <| repeat 3 5 == [5, 5, 5]
}

func take n it = do() {
  let mut i = 0
  with it!() {
    when 'next(val) if i < n then {
      i += 1
      become yield 'next(val)
    }
    when 'next(_) cancel unit
  }
}

test "iterator take" {
  let it = do() {
    yield 'next(1)
    yield 'next(2)
    yield 'next(3)
  }
  assert collect <| take 2 it == [1, 2]
}

func chunks 0 _ = yield 'arg
func chunks n it = do() {
  let mut chunk = []
  with it!() {
    when 'next(item) then {
      chunk = [..chunk, item]
      if array::length chunk == n {
        yield 'next(chunk)
        chunk = []
      }
      become unit
    }
  }
  if chunk != [] { yield 'next(chunk) }
}

test "iterator chunks" {
  assert collect <| chunks 3 <| range 1 9 == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
  assert collect <| chunks 3 <| range 1 7 == [[1, 2, 3], [4, 5, 6], [7]]
  assert collect <| chunks 1 <| range 1 3 == [[1], [2], [3]]
  with chunks 0 { when 'arg cancel unit }
}

func range_step _ _ 0 = yield 'arg
func range_step from to step = do() {
  let cmp = if step > 0 then (<=) else (>=)
  let mut i = from
  while cmp i to {
    yield 'next(i)
    i += step
  }
}

test "iterator range_step" {
  assert collect <| range_step 0 5 1 == [0, 1, 2, 3, 4, 5]
  assert collect <| range_step 5 1 (-1) == [5, 4, 3, 2, 1]
  assert collect <| range_step 0 5 (-1) == []
  assert collect <| range_step 5 1 1 == []
  assert collect <| range_step 0 5 2 == [0, 2, 4]
}

func rangex_step _ _ 0 = yield 'arg
func rangex_step from to step = do() {
  let cmp = if step > 0 then (<) else (>)
  let mut i = from
  while cmp i to {
    yield 'next(i)
    i += step
  }
}

test "iterator rangex_step" {
  assert collect <| rangex_step 0 5 1 == [0, 1, 2, 3, 4]
  assert collect <| rangex_step 5 1 (-1) == [5, 4, 3, 2]
  assert collect <| rangex_step 0 5 (-1) == []
  assert collect <| rangex_step 5 1 1 == []
  assert collect <| rangex_step 0 5 2 == [0, 2, 4]
}

func range from to = if from < to then range_step from to 1 else range_step from to (-1)

test "iterator range" {
  assert collect <| range 0 5 == [0, 1, 2, 3, 4, 5]
  assert collect <| range 5 1 == [5, 4, 3, 2, 1]
  assert collect <| range 0 0 == [0]
}

func rangex from to = if from < to then rangex_step from to 1 else rangex_step from to (-1)

test "iterator rangex" {
  assert collect <| rangex 0 5 == [0, 1, 2, 3, 4]
  assert collect <| rangex 5 1 == [5, 4, 3, 2]
  assert collect <| rangex 0 0 == []
}

func filter predicate it = do() {
  with it!() {
    when 'next(val) if predicate val resume yield 'next(val)
    when 'next(_) resume unit
  }
}

test "iterator filter" {
  assert collect <| filter (fn i. i % 2 == 0) <| range 1 5 == [2, 4]
}

func map f it = do() {
  with it!() {
    when 'next(val) resume yield 'next(f val)
  }
}

test "iterator map" {
  assert collect <| map ((*) 2) <| range 1 5 == [2, 4, 6, 8, 10]
}

func flat_map f it = do() {
  with it!() {
    when 'next(val) then {
      let inner = f val
      inner!()
      become unit
    }
  }
}

test "iterator flat_map" {
  assert collect <| flat_map (range 0) <| range 0 3 == [0, 0, 1, 0, 1, 2, 0, 1, 2, 3]
}

func scan f a it = do() {
  let mut state = a
  with it!() {
    when 'next(val) then {
      state = f state val
      become yield 'next(state)
    }
  }
}

test "iterator scan" {
  assert collect <| scan (+) 0 <| range 1 5 == [1, 3, 6, 10, 15]
}

func fold f a it =
  let mut state = a,
  with { it!(); state } {
    when 'next(val) then {
      state = f state val
      become unit
    }
  }

test "iterator fold" {
  assert fold (:) 0 <| range 1 5 == ((((0:1):2):3):4):5
}

func reduce f it =
  let mut state = 'none,
  with {
    it!()
    match state {
      case 'some(v) then v
      else yield 'mia
    }
  } {
    when 'next(val) then {
      state = match state {
        case 'some(prev) then 'some(f prev val)
        else 'some(val)
      }
      become unit
    }
  }

test "iterator reduce" {
  assert reduce (:) <| range 1 5 == (((1:2):3):4):5
  assert with reduce (:) <| rangex 0 0 { when 'mia cancel true else cancel false }
}

func sum it = fold (+) 0 it

test "iterator sum" {
  assert sum <| range 1 5 == 15
}

func count it = fold (fn a _. a + 1) 0 it

test "iterator count" {
  assert count <| range 1 5 == 5
}

func any predicate it = 
  with { it!(); false } {
    when 'next(val) then {
      if predicate val {
        return true
      }
      become unit
    }
  }

test "iterator any" {
  assert any ((==) 2) <| range 1 3
  assert !(any ((==) 5) <| range 1 3)
  assert any ((==) 1) <| forever 1
}

func all predicate it = 
  with { it!(); true } {
    when 'next(val) then {
      if !(predicate val) {
        return false
      }
      become unit
    }
  }

test "iterator all" {
  assert !(all (fn x. x < 2) <| range 1 3)
  assert all (fn x. x < 5) <| range 1 3
  assert !(all ((==) 1) <| forever 2)
}

func enumerate it = do() {
  let mut i = 0
  with it!() {
    when 'next(v) then {
      let j = i
      i += 1
      become yield 'next(j:v)
    }
  }
}

test "iterator enumerate" {
  assert collect <| enumerate <| range 3 5 == [0:3, 1:4, 2:5]
}

func find p it = 
  with { it!(); yield 'mia } {
    when 'next(v) then {
      if p v {
        return v
      }
      become unit
    }
  }

test "iterator find" {
  assert find ((==) 4) <| range 3 5 == 4
  assert with find ((==) 4) <| range 1 3 { when 'mia cancel true else cancel false }
}

func choose 0 _ = do() yield 'next([])
func choose _ [] = do() {}
func choose n [x, ..xs] = do() {
  run <| map (array::prepend x) <| choose (n - 1) xs
  run <| choose n xs
}

test "iterator choose" {
  assert collect <| choose 2 [1, 2, 3] == [[1, 2], [1, 3], [2, 3]]
  assert collect <| choose 0 [1, 2, 3] == [[]]
}

func for_each f it =
  with { it!(); unit } {
    when 'next(v) then {
      f v
      become unit
    }
  }

test "iterator for_each" {
  let arr = []
  assert for_each (fn n. array::push!(arr, n)) <| range 1 4 == unit
  assert arr == [1, 2, 3, 4]
}
