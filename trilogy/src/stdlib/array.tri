import "trilogy:core" as core
import "trilogy:number" as num

export push, pop, extend, length, map, flat_map, filter, fold, rfold, reduce, rreduce, reverse, concat, append, prepend, first, last, tail, head, slice, take, skip, drop, collect, chunks, sort, sort_by, zip, transpose, rotate_cw, rotate_ccw, flatten, any, all

proc push!(arr and typeof 'array, value) {
  core::push!(arr, value)
  return arr
}

test "array push" {
  let array = []
  assert push!(array, 3) === array
  assert array == [3]
  assert push!(array, 4) === array
  assert array == [3, 4]
}

proc pop!(arr and typeof 'array) {
  if length arr == 0 {
    return yield 'mia
  } else {
    return core::pop!(arr)
  }
}

test "array pop" {
  let array = [1, 2, 3]
  assert pop!(array) == 3
  assert array == [1, 2]
  assert pop!(array) == 2
  assert array == [1]
}

proc extend!(arr and typeof 'array, value and typeof 'array) {
  core::append!(arr, value)
  return arr
}

test "array push" {
  let array = []
  assert extend!(array, [1, 2]) === array
  assert array == [1, 2]
  assert extend!(array, [3, 4]) === array
  assert array == [1, 2, 3, 4]
}

func length (arr and typeof 'array) = core::length arr

test "array length" {
  assert length [] == 0
  assert length [1] == 1
  assert length [1, 2, 3] == 3
}

func map _ [] = []
func map f [x, ..xs] = [f x, ..map f xs]

test "array map" {
  assert map (fn x. x * 2) [] == []
  assert map (fn x. x * 2) [1] == [2]
  assert map (fn x. x * 2) [1, 2, 3] == [2, 4, 6]
  let arr = [1, 2, 3]
  let doubled = map (fn x. x * 2) arr
  assert arr == [1, 2, 3]
}

func flat_map _ [] = []
func flat_map f [x, ..xs] = [..f x, ..flat_map f xs]

test "array flat_map" {
  assert flat_map (fn x. [x * 2, x / 2]) [] == []
  assert flat_map (fn x. [x * 2, x / 2]) [1] == [2, 1/2]
  assert flat_map (fn x. [x * 2, x / 2]) [1, 2, 3] == [2, 1/2, 4, 1, 6, 3/2]
}

func filter _ [] = []
func filter p [x, ..xs] =
  if p x
    then [x, ..filter p xs]
    else filter p xs

test "array filter" {
  assert filter (fn x. x % 2 == 0) [] == []
  assert filter (fn x. x % 2 == 0) [1] == []
  assert filter (fn x. x % 2 == 0) [1, 2, 3] == [2]
  let arr = [1, 2, 3]
  let evens = filter (fn x. x % 2 == 0) arr
  assert arr == [1, 2, 3]
}

func fold _ a [] = a
func fold f a [x, ..xs] = fold f (f a x) xs

test "array fold" {
  assert fold (+) 0 [1, 2, 3, 4] == 10
  assert fold (+) 0 [] == 0
  assert fold (:) 0 [1, 2, 3] == ((0:1):2):3
}

func rfold _ a [] = a
func rfold f a [x, ..xs] = f (rfold f a xs) x

test "array rfold" {
  assert rfold (+) 0 [1, 2, 3, 4] == 10
  assert rfold (+) 0 [] == 0
  assert rfold (:) 0 [1, 2, 3] == ((0:3):2):1
}

func reduce f [] = yield 'mia
func reduce f [x, ..xs] = fold f x xs

test "array reduce" {
  assert reduce (+) [1, 2, 3, 4] == 10
  assert with (reduce (+) []; false)
    when 'mia cancel true
    else yield
  assert reduce (:) [1, 2, 3] == (1:2):3
}

func rreduce f [] = yield 'mia
func rreduce f [..xs, x] = rfold f x xs

test "array rreduce" {
  assert rreduce (+) [1, 2, 3, 4] == 10
  assert with (rreduce (+) []; false)
    when 'mia cancel true
    else yield
  assert rreduce (:) [1, 2, 3] == (3:2):1
}

func reverse [] = []
func reverse [x, ..xs] = [..reverse xs, x]

test "array reverse" {
  assert reverse [] == []
  assert reverse [1, 2, 3] == [3, 2, 1]
  let x = [1, 2, 3]
  let y = reverse x
  assert x == [1, 2, 3]
}

func concat (xs and typeof 'array) (ys and typeof 'array) = [..xs, ..ys]

test "array concat" {
  assert concat [1, 2] [3, 4] == [1, 2, 3, 4]
  assert concat [] [] == []
}

func append x (xs and typeof 'array) = [..xs, x]

test "array append" {
  assert append 3 [1, 2] == [1, 2, 3]
  assert append [] [1, 2] == [1, 2, []]
  let x = [1, 2]
  assert append 3 x == [1, 2, 3]
  assert x == [1, 2]
}

func prepend x (xs and typeof 'array) = [x, ..xs]

test "array prepend" {
  assert prepend 3 [1, 2] == [3, 1, 2]
  assert prepend [] [1, 2] == [[], 1, 2]
  let x = [1, 2]
  assert prepend 3 x == [3, 1, 2]
  assert x == [1, 2]
}

func first [] = yield 'mia
func first [x, .._] = x

test "array first" {
  assert first [1, 2, 3] == 1
  assert with (first []; false)
    when 'mia cancel true
    else yield
}

func last [] = yield 'mia
func last [.._, x] = x

test "array last" {
  assert last [1, 2, 3] == 3
  assert with (last []; false)
    when 'mia cancel true
    else yield
}

func tail [] = yield 'mia
func tail [_, ..xs] = xs

test "array tail" {
  assert tail [1, 2, 3] == [2, 3]
  assert with (tail []; false)
    when 'mia cancel true
    else yield
}

func head [] = yield 'mia
func head [..xs, _] = xs

test "array head" {
  assert head [1, 2, 3] == [1, 2]
  assert with (head []; false)
    when 'mia cancel true
    else yield
}

func slice i fin (arr and typeof 'array) = core::slice i fin arr

test "array slice" {
  assert slice 0 3 [1, 2, 3] == [1, 2, 3]
  assert slice 1 2 [1, 2, 3] == [2]
  assert slice 1 1 [1, 2, 3] == []
  assert slice 1 3 [1, 2, 3] == [2, 3]
  assert with (slice (-1) 2 [1, 2, 3]; false)
    when 'arg cancel true
    else yield
  assert with (slice 2 1 [1, 2, 3]; false)
    when 'arg cancel true
    else yield
  assert with (slice 0 5 [1, 2, 3]; false)
    when 'mia cancel true
    else yield
  assert with (slice 5 5 [1, 2, 3]; false)
    when 'mia cancel true
    else yield
}

func take n (arr and typeof 'array) =
  if n <= length arr
    then slice 0 n arr
    else slice 0 (length arr) arr

test "array take" {
  assert take 0 [1, 2, 3] == []
  assert take 1 [1, 2, 3] == [1]
  assert take 2 [1, 2, 3] == [1, 2]
  assert take 3 [1, 2, 3] == [1, 2, 3]
  assert take 12 [1, 2, 3] == [1, 2, 3]
  assert with (take (-1) [1, 2, 3]; false)
    when 'arg cancel true
    else yield
}

func skip n (arr and typeof 'array) =
  if n < length arr
    then slice n (length arr) arr
    else []

test "array skip" {
  assert skip 0 [1, 2, 3] == [1, 2, 3]
  assert skip 1 [1, 2, 3] == [2, 3]
  assert skip 2 [1, 2, 3] == [3]
  assert skip 3 [1, 2, 3] == []
  assert skip 12 [1, 2, 3] == []
  assert with (skip (-1) [1, 2, 3]; false)
    when 'arg cancel true
    else yield
}

func drop n (arr and typeof 'array) =
  if n < 0 then yield 'arg
  else if n >= length arr then []
  else slice 0 (length arr - n) arr

test "array drop" {
  assert drop 0 [1, 2, 3] == [1, 2, 3]
  assert drop 1 [1, 2, 3] == [1, 2]
  assert drop 2 [1, 2, 3] == [1]
  assert drop 3 [1, 2, 3] == []
  assert drop 12 [1, 2, 3] == []
  assert with (drop (-1) [1, 2, 3]; false)
    when 'arg cancel true
    else yield
}

func collect iterator =
  let arr = [],
  with (iterator!(); arr)
    when 'next(val) then {
      push!(arr, val)
      become unit
    }
    else yield

test "array collect" {
  let iterator = do() {
    yield 'next(1)
    yield 'next(2)
    yield 'next(3)
  }
  assert collect iterator == [1, 2, 3]
}

func chunks 0 _ = yield 'arg
func chunks _ [] = []
func chunks n arr = [take n arr, ..chunks n (skip n arr)]

test "array chunks" {
  assert chunks 3 [1, 2, 3, 4, 5, 6, 7, 8, 9] == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
  assert chunks 3 [1, 2, 3, 4, 5, 6, 7] == [[1, 2, 3], [4, 5, 6], [7]]
  assert chunks 1 [1, 2, 3] == [[1], [2], [3]]
  with chunks 0 when 'arg cancel unit else yield
}

func merge _ a [] = a
func merge _ [] a = a
func merge cmp [x, ..xs] and xss [y, ..ys] and yss = if cmp x y then [x, ..merge cmp xs yss] else [y, ..merge cmp xss ys]

func sort_by _ [] = []
func sort_by _ [a] = [a]
func sort_by cmp arr =
  let lhs = sort_by cmp <| take (length arr // 2) arr,
  let rhs = sort_by cmp <| skip (length arr // 2) arr,
  merge cmp lhs rhs

test "array sort_by" {
  assert sort_by (<) [5, 3, 2, 1, 3, 2, 9] == [1, 2, 2, 3, 3, 5, 9]
  assert sort_by (>) [5, 3, 2, 1, 3, 2, 9] == [9, 5, 3, 3, 2, 2, 1]
  assert sort_by (fn l r. l.'left < r.'left) ['a':5, 'c':2, 'b':9] == ['a':5, 'b':9, 'c':2]
}

func sort arr = sort_by (<) arr

test "array sort" {
  assert sort [5, 3, 2, 1, 3, 2, 9] == [1, 2, 2, 3, 3, 5, 9]
  assert sort ['a', 'c', 'b', 'e', 'd'] == ['a', 'b', 'c', 'd', 'e']
  assert sort [] == []
}

func zip [] _ = []
func zip _ [] = []
func zip [a, ..ra] [b, ..rb] = [a:b, ..zip ra rb]

test "array zip" {
  assert zip [] [1] == []
  assert zip [1] [] == []
  assert zip [1, 2, 3] [4, 5, 6] == [1:4, 2:5, 3:6]
  assert zip [1, 2, 3] [1, 2] == [1:1, 2:2]
}

func unzip tuples = rfold (fn xs:ys x:y. ([x, ..xs] : [y, ..ys])) ([]:[]) tuples

test "array  unzip" {
  assert unzip [1:2, 3:4, 5:6] == [1, 3, 5]:[2, 4, 6]
}

func transpose [] = []
func transpose [[], ..xss] = transpose xss
func transpose [[x, ..xs], ..xss] =
  let combine = fn y h ys t. [[y, ..h], ..transpose [ys, ..t]],
  let hds:tls = unzip [hd:tl for [hd, ..tl] in xss],
  combine x hds xs tls

test "array transpose" {
  assert transpose [] == []
  assert transpose [[]] == []
  assert transpose [[], []] == []
  assert transpose [[1, 2, 3], [4, 5, 6]] == [[1, 4], [2, 5], [3, 6]]
  assert transpose [[1, 2, 3]] == [[1], [2], [3]]
  assert transpose [[1, 2, 3], [1, 2]] == [[1, 1], [2, 2], [3]]
  assert transpose [[1, 2, 3], [1, 2], [1, 2, 3]] == [[1, 1, 1], [2, 2, 2], [3, 3]]
}

func rotate_cw array = array |> reverse |> transpose

test "array rotate_cw" {
  assert rotate_cw [] == []
  assert rotate_cw [[1, 2, 3], [4, 5, 6], [7, 8, 9]] == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]
}

func rotate_ccw array = array |> transpose |> reverse

test "array rotate_ccw" {
  assert rotate_ccw [] == []
  assert rotate_ccw [[7, 4, 1], [8, 5, 2], [9, 6, 3]] == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
}

func flatten [] = []
func flatten [xs, ..xss] = [..xs, ..flatten xss]

test "array flatten" {
  assert flatten [] == []
  assert flatten [[]] == []
  assert flatten [[1, 2], [2, 4]] == [1, 2, 2, 4]
  assert flatten [[1, 2, [3]], [2, 4]] == [1, 2, [3], 2, 4]
}

func any _ [] = false
func any f [x, ..xs] = f x || any f xs

test "array any" {
  assert !(any (fn x. x % 2 == 0) [])
  assert any (fn x. x % 2 == 0) [1, 2, 3]
  assert !(any (fn x. x % 2 == 0) [1, 3])
}

func all _ [] = true
func all f [x, ..xs] = f x && all f xs

test "array all" {
  assert all (fn x. x % 2 == 0) []
  assert !(all (fn x. x % 2 == 0) [1, 2, 3])
  assert all (fn x. x % 2 == 0) [2, 4]
}
