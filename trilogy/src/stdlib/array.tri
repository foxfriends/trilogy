import "trilogy:core" as core

export push, extend, length, map, filter, fold, rfold, reduce, rreduce, reverse, concat, append, prepend, first, last, tail, head, slice, take, skip, drop, collect

proc push!(arr and typeof 'array, value) {
  core::push!(arr, value)
  return arr
}

test "array push" {
  let array = []
  assert push!(array, 3) === array
  assert array == [3]
  assert push!(array, 4) === array
  assert array == [3, 4]
}

proc extend!(arr and typeof 'array, value and typeof 'array) {
  core::append!(arr, value)
  return arr
}

test "array push" {
  let array = []
  assert extend!(array, [1, 2]) === array
  assert array == [1, 2]
  assert extend!(array, [3, 4]) === array
  assert array == [1, 2, 3, 4]
}

func length (arr and typeof 'array) = core::length arr

test "array length" {
  assert length [] == 0
  assert length [1] == 1
  assert length [1, 2, 3] == 3
}

func map _ [] = []
func map f [x, ..xs] = [f x, ..map f xs]

test "array map" {
  assert map (fn x. x * 2) [] == []
  assert map (fn x. x * 2) [1] == [2]
  assert map (fn x. x * 2) [1, 2, 3] == [2, 4, 6]
  let arr = [1, 2, 3]
  let doubled = map (fn x. x * 2) arr
  assert arr == [1, 2, 3]
}

func filter _ [] = []
func filter p [x, ..xs] =
  if p x
    then [x, ..filter p xs]
    else filter p xs

test "array filter" {
  assert filter (fn x. x % 2 == 0) [] == []
  assert filter (fn x. x % 2 == 0) [1] == []
  assert filter (fn x. x % 2 == 0) [1, 2, 3] == [2]
  let arr = [1, 2, 3]
  let evens = filter (fn x. x % 2 == 0) arr
  assert arr == [1, 2, 3]
}

func fold _ a [] = a
func fold f a [x, ..xs] = fold f (f a x) xs

test "array fold" {
  assert fold (+) 0 [1, 2, 3, 4] == 10
  assert fold (+) 0 [] == 0
  assert fold (:) 0 [1, 2, 3] == ((0:1):2):3
}

func rfold _ a [] = a
func rfold f a [x, ..xs] = f (rfold f a xs) x

test "array rfold" {
  assert rfold (+) 0 [1, 2, 3, 4] == 10
  assert rfold (+) 0 [] == 0
  assert rfold (:) 0 [1, 2, 3] == ((0:3):2):1
}

func reduce f [] = yield 'mia
func reduce f [x, ..xs] = fold f x xs

test "array reduce" {
  assert reduce (+) [1, 2, 3, 4] == 10
  assert with (reduce (+) []; false)
    when 'mia cancel true
    else yield
  assert reduce (:) [1, 2, 3] == (1:2):3
}

func rreduce f [] = yield 'mia
func rreduce f [..xs, x] = rfold f x xs

test "array rreduce" {
  assert rreduce (+) [1, 2, 3, 4] == 10
  assert with (rreduce (+) []; false)
    when 'mia cancel true
    else yield
  assert rreduce (:) [1, 2, 3] == (3:2):1
}

func reverse [] = []
func reverse [x, ..xs] = [..reverse xs, x]

test "array reverse" {
  assert reverse [] == []
  assert reverse [1, 2, 3] == [3, 2, 1]
  let x = [1, 2, 3]
  let y = reverse x
  assert x == [1, 2, 3]
}

func concat (xs and typeof 'array) (ys and typeof 'array) = [..xs, ..ys]

test "array concat" {
  assert concat [1, 2] [3, 4] == [1, 2, 3, 4]
  assert concat [] [] == []
}

func append x (xs and typeof 'array) = [..xs, x]

test "array append" {
  assert append 3 [1, 2] == [1, 2, 3]
  assert append [] [1, 2] == [1, 2, []]
  let x = [1, 2]
  assert append 3 x == [1, 2, 3]
  assert x == [1, 2]
}

func prepend x (xs and typeof 'array) = [x, ..xs]

test "array prepend" {
  assert prepend 3 [1, 2] == [3, 1, 2]
  assert prepend [] [1, 2] == [[], 1, 2]
  let x = [1, 2]
  assert prepend 3 x == [3, 1, 2]
  assert x == [1, 2]
}

func first [] = yield 'mia
func first [x, .._] = x

test "array first" {
  assert first [1, 2, 3] == 1
  assert with (first []; false)
    when 'mia cancel true
    else yield
}

func last [] = yield 'mia
func last [.._, x] = x

test "array last" {
  assert last [1, 2, 3] == 3
  assert with (last []; false)
    when 'mia cancel true
    else yield
}

func tail [] = yield 'mia
func tail [_, ..xs] = xs

test "array tail" {
  assert tail [1, 2, 3] == [2, 3]
  assert with (tail []; false)
    when 'mia cancel true
    else yield
}

func head [] = yield 'mia
func head [..xs, _] = xs

test "array head" {
  assert head [1, 2, 3] == [1, 2]
  assert with (head []; false)
    when 'mia cancel true
    else yield
}

func slice i fin (arr and typeof 'array) = core::slice i fin arr

test "array slice" {
  assert slice 0 3 [1, 2, 3] == [1, 2, 3]
  assert slice 1 2 [1, 2, 3] == [2]
  assert slice 1 1 [1, 2, 3] == []
  assert slice 1 3 [1, 2, 3] == [2, 3]
  assert with (slice (-1) 2 [1, 2, 3]; false)
    when 'arg cancel true
    else yield
  assert with (slice 2 1 [1, 2, 3]; false)
    when 'arg cancel true
    else yield
  assert with (slice 0 5 [1, 2, 3]; false)
    when 'mia cancel true
    else yield
  assert with (slice 5 5 [1, 2, 3]; false)
    when 'mia cancel true
    else yield
}

func take n (arr and typeof 'array) =
  if n <= length arr
    then slice 0 n arr
    else slice 0 (length arr) arr

test "array take" {
  assert take 0 [1, 2, 3] == []
  assert take 1 [1, 2, 3] == [1]
  assert take 2 [1, 2, 3] == [1, 2]
  assert take 3 [1, 2, 3] == [1, 2, 3]
  assert take 12 [1, 2, 3] == [1, 2, 3]
  assert with (take (-1) [1, 2, 3]; false)
    when 'arg cancel true
    else yield
}

func skip n (arr and typeof 'array) =
  if n < length arr
    then slice n (length arr) arr
    else []

test "array skip" {
  assert skip 0 [1, 2, 3] == [1, 2, 3]
  assert skip 1 [1, 2, 3] == [2, 3]
  assert skip 2 [1, 2, 3] == [3]
  assert skip 3 [1, 2, 3] == []
  assert skip 12 [1, 2, 3] == []
  assert with (skip (-1) [1, 2, 3]; false)
    when 'arg cancel true
    else yield
}

func drop n (arr and typeof 'array) =
  if n < 0 then yield 'arg
  else if n >= length arr then []
  else slice 0 (length arr - n) arr

test "array drop" {
  assert drop 0 [1, 2, 3] == [1, 2, 3]
  assert drop 1 [1, 2, 3] == [1, 2]
  assert drop 2 [1, 2, 3] == [1]
  assert drop 3 [1, 2, 3] == []
  assert drop 12 [1, 2, 3] == []
  assert with (drop (-1) [1, 2, 3]; false)
    when 'arg cancel true
    else yield
}

func collect iterator =
  let arr = [],
  with (iterator!(); arr)
    when 'next(val) then {
      push!(arr, val)
      become unit
    }
    else yield

test "array collect" {
  let iterator = do() {
    yield 'next(1)
    yield 'next(2)
    yield 'next(3)
  }
  assert collect iterator == [1, 2, 3]
}
