## Computes a new array by applying the function `f` to each element
## of the original array.
func map f [] = []
func map f [x, ..xs] = [f x, ..map f xs]
export map

test "map works" {
    assert map (fn x. x * 2) [1, 2, 3] == [2, 4, 6]
}

test "map works on empty arrays" {
    assert map (fn _. end) [] == []
}

test not "map accepts a closure" {
    map (do(n) { return 2 * n }) [1, 2, 3]
}

## Computes a new array by removing all values for which the predicate `f`
## returns `false`.
func filter f [] = []
func filter f [x, ..xs] = if f x then [x, ..filter f xs] else filter f xs
export filter

test "filter works" {
    assert filter (fn x. x > 3) [1, 2, 3, 4, 5] == [4, 5]
}

test "filter works on empty arrays" {
    assert filter (fn _. end) [] == []
}

test not "filter accepts a closure" {
    filter (do(x) { return x > 3 }) [1, 2, 3, 4, 5]
}

## Computes a single value from an array by starting with the accumulator `a` and
## applying `f acc x` for each element `x` of the array, starting from the
## first (leftmost) element.
func fold f a [] = a
func fold f a [x, ..xs] = fold f (f a x) xs
export fold

test "fold works from left to right" {
    assert fold (fn a b. a:b) 0 [1, 2, 3] == ((0:1):2):3
}

test "fold returns the initial value for empty arrays" {
    assert fold (fn _ _. end) 0 [] == 0
}

## Computes a single value from an array by starting with the accumulator `a` and
## applying `f acc x` for each element `x` of the array, starting from the
## last (rightmost) element.
func foldr f a [] = a
func foldr f a [..xs, x] = foldr f (f a x) xs
export foldr

test "foldr works from right to left" {
    assert foldr (fn a b. a:b) 0 [1, 2, 3] == ((0:3):2):1
}

test "foldr returns the initial value for empty arrays" {
    assert foldr (fn _ _. end) 0 [] == 0
}

## Returns the first element of the array. If the array is empty, yields 'MIA
func first [x, .._] = x
func first [] = yield 'MIA
export first

test "first returns the first element" {
    assert first [1, 2] == 1
}

test "yields 'MIA when empty" {
    with first []
        when 'MIA cancel { exit unit }
        else cancel {}
    assert false
}

## Returns the last element of the array. If the array is empty, yields 'MIA
func last [.._, x] = x
func last [] = yield 'MIA
export last

test "last returns the last element" {
    assert last [1, 2] == 2
}

test "yields 'MIA when empty" {
    with last []
        when 'MIA cancel { exit unit }
        else cancel {}
    assert false
}

## Takes the first `n` elements of the array, discarding the rest.
## If the array's length is less than `n`, returns the whole array.
func take _ [] = []
func take 0 _ = []
func take n [x, ..xs] = [x, ..take (n - 1) xs]
export take

test "take returns the first `n` elements" {
    assert take 3 [1, 2, 3, 4, 5] == [1, 2, 3]
}

test "take returns less than `n` elements if there aren't enough" {
    assert take 3 [1, 2] == [1, 2]
}

test "take works on empty arrays" {
    assert take 3 [] == []
}

test "take can take none" {
    assert take 0 [1, 2] == []
}

## Skips the first `n` elements of the array, returning the rest.
## If the array's length is less than `n`, returns an empty array.
func skip _ [] = []
func skip 0 xs = xs
func skip n [_, ..xs] = skip (n - 1) xs
export skip

test "skip drops the first `n` elements" {
    assert skip 3 [1, 2, 3, 4, 5] == [4, 5]
}

test "skip returns an empty array if there aren't enough" {
    assert skip 3 [1, 2] == []
}

test "skip works on empty arrays" {
    assert skip 3 [] == []
}

test "skip can skip none" {
    assert skip 0 [1, 2] == [1, 2]
}

## Returns the length of the array.
func length [] = 0
func length [_, ..xs] = 1 + length xs
export length

test "length returns the length" {
    assert length [1, 2, 3] == 3
}

test "length returns the length of an empty array" {
    assert length [] == 0
}
