module native at "trilogy:array/native" use length, slice
export length, slice

test "length" {
    assert length [1, 2, 3] == 3
    assert length [] == 0
}

test "slice" {
    slice 2 4 [1, 2, 3, 4, 5, 6, 7, 8] == [3, 4, 5, 6]
    slice 7 4 [1, 2, 3, 4, 5, 6, 7, 8] == [8]
    slice 0 3 [1, 2, 3, 4, 5, 6, 7, 8] == [1, 2, 3]
}

## Returns an empty array
proc empty!() {
    return []
}
export empty

## Returns true if the array is empty, and false otherwise.
func is_empty [] = true
func is_empty typeof 'array = false
export is_empty

test "is_empty" {
    assert is_empty []
    assert !(is_empty [1])
    assert !(is_empty [[]])
}

## Returns an array of a single value
func of x = [x]
export of

## Creates a new array from the elements of an iterator.
func from iter = [x for x in iter]
export from

test "from" {
    assert from [1, 2, 3] == [1, 2, 3]

    let arr = from [| 1, 2, 3 |]
    assert contains 1 arr
    assert contains 2 arr
    assert contains 3 arr

    let arr2 = from {| 1 => 1, 2 => 2, 3 => 3 |}
    assert contains (1:1) arr2
    assert contains (2:2) arr2
    assert contains (3:3) arr2

    assert from (1:2:3:unit) == [1, 2, 3]
}

## Appends a single element to the array.
func append x arr = [..arr, x]
export append

test "append" {
    assert append 3 [1, 2] == [1, 2 ,3]
    assert append 3 [] == [3]
}

## Pushes an element onto the end of an array. The array is mutated.
## Returns the array.
proc push!(array, x) {
    array.(length array) = x
    return array
}
export push

test "push" {
    let arr = [1, 2]
    assert push!(arr, 3) === arr
    assert arr == [1, 2, 3]
}

## Computes a new array by applying the function `f` to each element
## of the original array.
func map f [] = []
func map f [x, ..xs] = [f x, ..map f xs]
export map

test "map" {
    assert map (fn x. x * 2) [1, 2, 3] == [2, 4, 6]
    assert map (fn _. end) [] == []
}

test not "map accepts a closure" {
    map (do(n) { return 2 * n }) [1, 2, 3]
}

## Computes a new array by applying the function `f` to each element
## of the original array to get intermediate arrays, which are each
## flattened.
func flatmap f [] = []
func flatmap f [x, ..xs] = [..f x, ..flatmap f xs]
export flatmap

test "flatmap" {
    assert flatmap (fn x. [x, x]) [1, 2, 3] == [1, 1, 2, 2, 3, 3]
    assert flatmap (fn x. [x, [x]]) [1, 2, 3] == [1, [1], 2, [2], 3, [3]]
}

## Flattens an array of arrays into a single array. Only flattens
## one layer deep.
func flatten [] = []
func flatten [x, ..xs] = [..x, ..flatten xs]
export flatten

test "flatten" {
    assert flatten [[1, 2], [3, 4]] == [1, 2, 3, 4]
    assert flatten [[1, [2]], [3, [4]]] == [1, [2], 3, [4]]
}

## Computes a new array by removing all values for which the predicate `f`
## returns `false`.
func filter f [] = []
func filter f [x, ..xs] = if f x then [x, ..filter f xs] else filter f xs
export filter

test "filter removes elements for which the predicate is false" {
    assert filter (fn x. x > 3) [1, 2, 3, 4, 5] == [4, 5]
}

test "filter works on empty arrays" {
    assert filter (fn _. end) [] == []
}

test not "filter accepts a closure" {
    filter (do(x) { return x > 3 }) [1, 2, 3, 4, 5]
}

## Computes a single value from an array by starting with the accumulator `a` and
## applying `f acc x` for each element `x` of the array, starting from the
## first (leftmost) element.
func fold f a [] = a
func fold f a [x, ..xs] = fold f (f a x) xs
export fold

test "fold works from left to right" {
    assert fold (fn a b. a:b) 0 [1, 2, 3] == ((0:1):2):3
}

test "fold returns the initial value for empty arrays" {
    assert fold (fn _ _. end) 0 [] == 0
}

## Computes a single value from an array by starting with the accumulator `a` and
## applying `f acc x` for each element `x` of the array, starting from the
## last (rightmost) element.
func foldr f a [] = a
func foldr f a [..xs, x] = foldr f (f a x) xs
export foldr

test "foldr works from right to left" {
    assert foldr (fn a b. a:b) 0 [1, 2, 3] == ((0:3):2):1
}

test "foldr returns the initial value for empty arrays" {
    assert foldr (fn _ _. end) 0 [] == 0
}

## Returns the first element of the array.
##
## # Yields
##
## * 'MIA if the array is empty
func first [x, .._] = x
func first [] = yield 'MIA
export first

test "first returns the first element" {
    assert first [1, 2] == 1
}

test "first yields 'MIA when empty" {
    with { first [] }
        when 'MIA invert { exit unit }
        else cancel unit
    assert false
}

## Returns the last element of the array.
##
## # Yields
##
## * 'MIA if the array is empty
func last [.._, x] = x
func last [] = yield 'MIA
export last

test "last returns the last element" {
    assert last [1, 2] == 2
}

test "last yields 'MIA when empty" {
    with { last [] }
        when 'MIA invert { exit unit }
        else cancel unit
    assert false
}

## Takes the first `n` elements of the array, discarding the rest.
## If the array's length is less than `n`, returns the whole array.
func take n = slice 0 n
export take

test "take returns the first `n` elements" {
    assert take 3 [1, 2, 3, 4, 5] == [1, 2, 3]
}

test "take returns less than `n` elements if there aren't enough" {
    assert take 3 [1, 2] == [1, 2]
}

test "take works on empty arrays" {
    assert take 3 [] == []
}

test "take can take none" {
    assert take 0 [1, 2] == []
}

## Skips the first `n` elements of the array, returning the rest.
## If the array's length is less than `n`, returns an empty array.
func skip n array = slice n (length array) array
export skip

test "skip drops the first `n` elements" {
    assert skip 3 [1, 2, 3, 4, 5] == [4, 5]
}

test "skip returns an empty array if there aren't enough" {
    assert skip 3 [1, 2] == []
}

test "skip works on empty arrays" {
    assert skip 3 [] == []
}

test "skip can skip none" {
    assert skip 0 [1, 2] == [1, 2]
}

## Returns true if the value `x` is contained within the array.
func contains x [] = false
func contains x [^x, .._] = true
func contains x [_, ..xs] = contains x xs
export contains

test "contains can find a value" {
    assert contains 3 [1, 2, 3]
}

test "contains can not find a value" {
    assert !(contains 4 [1, 2, 3])
}

test "empty array contains nothing" {
    assert !(contains 1 [])
}

## Returns the first element in the array for which the predicate returns true.
## If none is found, yields 'MIA
func find _ [] = yield 'MIA
func find f [x, ..xs] = if f x then x else find f xs
export find

test "find finds the first matching element" {
    assert find (fn x. x > 1) [1, 2, 3] == 2
}

test "find yields 'MIA when not found" {
    with { find (fn x. x > 4) [1, 2, 3] [] }
        when 'MIA invert { exit unit }
        else cancel unit
    assert false
}

## Returns true if the predicate returns true for any element in the array, or
## false otherwise. This will short circuit on the first element that returns true.
func any _ [] = false
func any f [x, ..xs] = if f x then true else any f xs
export any

test "any returns true when any element matches" {
    assert any (fn x. x > 1) [1, 2, 3]
}

test "any returns false when no element matches" {
    assert !(any (fn x. x > 4) [1, 2, 3])
}

test "any returns false for an empty array" {
    assert !(any (fn _. true) [])
}

test "any short circuits on the first matching element" {
    assert any (fn x. if x == 1 then true else end) [1, 2]
}

## Returns true if the predicate returns true for every element in the array, or
## false otherwise. This will short circuit on the first element that returns false.
func all _ [] = true
func all f [x, ..xs] = if f x then all f xs else false
export all

test "all returns true when all elements match" {
    assert all (fn x. x >= 1) [1, 2, 3]
}

test "all returns false when any elements don't match" {
    assert !(all (fn x. x > 1) [1, 2, 3])
}

test "all returns true for an empty array" {
    assert all (fn _. false) []
}

test "all short circuits on the first failing element" {
    assert !(all (fn x. if x == 1 then false else end) [1, 2])
}

func split_acc acc _ [] = [acc]
func split_acc acc f [x, ..xs] = if f x then [acc, ..split_acc [] f xs] else split_acc [..acc, x] f xs
func split pred arr = split_acc [] pred arr
export split

test "split" {
    assert split (fn x. x % 2 == 0) [1, 2, 3, 5, 4, 7] == [[1], [3, 5], [7]]
}

func chunks _ [] = []
func chunks 0 _ = []
func chunks n arr = [take n arr, ..chunks n (skip n arr)]
export chunks

test "chunks" {
    assert chunks 1 [1, 2, 3] == [[1], [2], [3]]
    assert chunks 2 [1, 2, 3] == [[1, 2], [3]]
}

func zip [] _ = []
func zip _ [] = []
func zip [x, ..xs] [y, ..ys] = [(x:y), ..zip xs ys]
export zip

test "zip" {
    assert zip [1, 2, 3] [4, 5, 6] == [1:4, 2:5, 3:6]
    assert zip [1, 2] [4, 5, 6] == [1:4, 2:5]
    assert zip [1, 2, 3] [4, 5] == [1:4, 2:5]
    assert zip [] [4, 5] == []
    assert zip [1, 2] [] == []
    assert zip [] [] == []
}

func partition pred arr =
    fold (fn l:r e. if pred e then append e l:r else l:append e r) ([]:[]) arr
export partition

test "partition" {
    assert partition ((>) 3) [1, 2, 3, 4, 5] == ([1, 2]:[3, 4, 5])
    assert partition ((<) 3) [1, 2, 3, 4, 5] == ([4, 5]:[1, 2, 3])
}

module io at "trilogy:io" use dbg

func merge _ xs [] = xs
func merge _ [] ys = ys
func merge cmp [x, ..xs] [y, ..ys] =
    if cmp x y
    then [x, ..merge cmp xs [y, ..ys]]
    else [y, ..merge cmp [x, ..xs] ys]

func sort _ [] = []
func sort _ [a] = [a]
func sort cmp arr =
    let half = length arr // 2,
    merge cmp (sort cmp <| take half arr) (sort cmp <| skip half arr)
export sort

test "sort" {
    assert sort (<) [3, 2, 5, 1, 4, 2, 7, 6, 5] == [1, 2, 2, 3, 4, 5, 5, 6, 7]
    assert sort (>) [3, 2, 5, 1, 4, 2, 7, 6, 5] == [7, 6, 5, 5, 4, 3, 2, 2, 1]
    assert sort (>) [[1, 2, 3], [1, 1, 1], [2, 3, 4], [3, 3, 3]] == [
        [3, 3, 3],
        [2, 3, 4],
        [1, 2, 3],
        [1, 1, 1],
    ]
}
