use super::Stack;
use crate::bytecode::{ChunkError, Offset};
use std::fmt::{self, Display};

// I am aware these names are not all that ergonomic, but they line up
// with what they are documented as.
//
// Maybe `Error` is not the best name for this enum, will revisit later.
/// An error that has occurred during the execution of a program.
#[derive(Clone, Debug)]
pub struct Error {
    /// The instruction pointer at which the error occurred. Note that since the
    /// instruction was already read, this is actually the pointer to the instruction
    /// following the one that caused the error.
    pub ip: Offset,
    /// The type of error that occurred.
    pub kind: ErrorKind,
    pub(crate) stack_dump: Stack,
}

impl std::error::Error for Error {}

impl Error {
    pub fn dump(&self) -> impl Display + '_ {
        &self.stack_dump
    }
}

impl Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Runtime error: {}", self.kind)
    }
}

/// The types of errors that may occur when executing a program.
#[allow(clippy::enum_variant_names)]
#[derive(Clone, Debug)]
pub enum ErrorKind {
    /// A value was provided to the VM that was not of the expected type.
    RuntimeTypeError,
    /// All executions in the program have fizzled without reaching a suitable exit.
    ExecutionFizzledError,
    /// The code generator has produced invalid bytecode.
    InvalidBytecode(ChunkError),
    /// Something went wrong inside the virtual machine. Likely an issue with the compiler
    /// of the language which is being run, rather than with the execution of the program
    /// itself.
    InternalRuntimeError(InternalRuntimeError),
}

impl Display for ErrorKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::RuntimeTypeError => write!(f, "type error"),
            Self::ExecutionFizzledError => write!(f, "execution fizzled"),
            Self::InvalidBytecode(error)  => write!(f, "invalid bytecode: {error}"),
            Self::InternalRuntimeError(internal) => write!(f, "internal error ({internal})\nIf you are seeing this error, it is not likely something wrong with your program, but something wrong with the bytecode generated by the compiler. Please file a bug report to foxfriends/trilogy on GitHub."),
        }
    }
}

#[derive(Copy, Clone, Debug)]
pub enum InternalRuntimeError {
    /// The generated bytecode contained an unknown opcode.
    InvalidOpcode(u8, u32),
    /// The generated bytecode referenced a register beyond the register limit.
    InvalidRegister,
    /// The generated bytecode referenced a pointer that does not exist.
    ///
    /// This should not possibly occur.
    InvalidPointer,
    /// The generated bytecode references a constant that does not exist.
    MissingConstant,
    /// The generated bytecode attempts to use a pointer after it has been freed.
    UseAfterFree,
    /// A value was expected on the stack but something else was found.
    ExpectedValue,
    /// A pointer was expected on the stack but something else was found.
    ExpectedPointer,
    /// A continuation's return stack was expected on the stack but something else was found.
    ExpectedStack,
    /// A procedure's return pointer was expected on the stack but something else was found.
    ExpectedReturn,
}

impl From<InternalRuntimeError> for ErrorKind {
    fn from(value: InternalRuntimeError) -> Self {
        Self::InternalRuntimeError(value)
    }
}

impl Display for InternalRuntimeError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidOpcode(op, ip) => write!(f, "invalid opcode {op} at {ip}"),
            Self::InvalidRegister => write!(f, "invalid register"),
            Self::InvalidPointer => write!(f, "invalid pointer"),
            Self::MissingConstant => write!(f, "missing constant"),
            Self::UseAfterFree => write!(f, "use after free"),
            Self::ExpectedValue => write!(f, "expected value on stack"),
            Self::ExpectedPointer => write!(f, "expected pointer on stack"),
            Self::ExpectedStack => write!(f, "expected stack on stack"),
            Self::ExpectedReturn => write!(f, "expected return pointer on stack"),
        }
    }
}
