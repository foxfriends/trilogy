use crate::Program;

use super::{stack::StackTrace, Stack};
use std::fmt::{self, Display};

// I am aware these names are not all that ergonomic, but they line up
// with what they are documented as.
//
// Maybe `Error` is not the best name for this enum, will revisit later.
#[derive(Clone, Debug)]
pub struct Error {
    pub ip: usize,
    pub kind: ErrorKind,
    pub(crate) stack_dump: Stack,
}

impl std::error::Error for Error {}

impl Error {
    pub fn trace(&self, program: &Program) -> StackTrace {
        self.stack_dump.trace(self.ip, program)
    }

    pub fn dump(&self) -> impl Display + '_ {
        &self.stack_dump
    }
}

impl Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Runtime error: {}", self.kind)
    }
}

#[allow(clippy::enum_variant_names)]
#[derive(Copy, Clone, Debug)]
pub enum ErrorKind {
    RuntimeTypeError,
    AssertionError,
    ExecutionFizzledError,
    InternalRuntimeError(InternalRuntimeError),
}

impl Display for ErrorKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::RuntimeTypeError => write!(f, "type error"),
            Self::AssertionError => write!(f, "assertion error"),
            Self::ExecutionFizzledError => write!(f, "execution fizzled"),
            Self::InternalRuntimeError(internal) => write!(f, "internal error ({internal}))\nIf you are seeing this error, it is not likely something wrong with your program, but something wrong with the bytecode generated by the compiler. Please file a bug report to foxfriends/trilogy on GitHub."),
        }
    }
}

#[derive(Copy, Clone, Debug)]
pub enum InternalRuntimeError {
    InvalidOpcode,
    InvalidOffset,
    InvalidPointer,
    MissingConstant,
    UseAfterFree,
    ExpectedValue,
    ExpectedPointer,
    ExpectedStack,
    ExpectedReturn,
}

impl From<InternalRuntimeError> for ErrorKind {
    fn from(value: InternalRuntimeError) -> Self {
        Self::InternalRuntimeError(value)
    }
}

impl Display for InternalRuntimeError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidOpcode => write!(f, "invalid opcode"),
            Self::InvalidOffset => write!(f, "invalid offset"),
            Self::InvalidPointer => write!(f, "invalid pointer"),
            Self::MissingConstant => write!(f, "missing constant"),
            Self::UseAfterFree => write!(f, "use after free"),
            Self::ExpectedValue => write!(f, "expected value on stack"),
            Self::ExpectedPointer => write!(f, "expected pointer on stack"),
            Self::ExpectedStack => write!(f, "expected stack on stack"),
            Self::ExpectedReturn => write!(f, "expected return pointer on stack"),
        }
    }
}
