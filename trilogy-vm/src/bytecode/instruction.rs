use super::OpCode;
use crate::Value;
use std::fmt::{self, Display};

pub type Offset = usize;

#[derive(Debug)]
pub enum Instruction {
    Const(Value),
    Load,
    Set,
    Alloc,
    Free,
    LoadRegister(Offset),
    SetRegister(Offset),
    Copy,
    Pop,
    Swap,
    Add,
    Subtract,
    Multiply,
    Divide,
    Remainder,
    IntDivide,
    Power,
    Negate,
    Glue,
    Access,
    Assign,
    Not,
    And,
    Or,
    BitwiseAnd,
    BitwiseOr,
    BitwiseXor,
    BitwiseNeg,
    LeftShift,
    RightShift,
    Cons,
    Leq,
    Lt,
    Geq,
    Gt,
    RefEq,
    ValEq,
    RefNeq,
    ValNeq,
    Call(Offset),
    Return,
    Shift(Offset),
    Reset,
    Jump(Offset),
    JumpBack(Offset),
    CondJump(Offset),
    CondJumpBack(Offset),
    Branch,
    Fizzle,
    Exit,
}

impl Instruction {
    pub fn op_code(&self) -> OpCode {
        match self {
            Self::Const(..) => OpCode::Const,
            Self::Load => OpCode::Load,
            Self::Set => OpCode::Set,
            Self::Alloc => OpCode::Alloc,
            Self::Free => OpCode::Free,
            Self::LoadRegister(..) => OpCode::LoadRegister,
            Self::SetRegister(..) => OpCode::SetRegister,
            Self::Copy => OpCode::Copy,
            Self::Pop => OpCode::Pop,
            Self::Swap => OpCode::Swap,
            Self::Add => OpCode::Add,
            Self::Subtract => OpCode::Subtract,
            Self::Multiply => OpCode::Multiply,
            Self::Divide => OpCode::Divide,
            Self::Remainder => OpCode::Remainder,
            Self::IntDivide => OpCode::IntDivide,
            Self::Power => OpCode::Power,
            Self::Negate => OpCode::Negate,
            Self::Glue => OpCode::Glue,
            Self::Access => OpCode::Access,
            Self::Assign => OpCode::Assign,
            Self::Not => OpCode::Not,
            Self::And => OpCode::And,
            Self::Or => OpCode::Or,
            Self::BitwiseAnd => OpCode::BitwiseAnd,
            Self::BitwiseOr => OpCode::BitwiseOr,
            Self::BitwiseXor => OpCode::BitwiseXor,
            Self::BitwiseNeg => OpCode::BitwiseNeg,
            Self::LeftShift => OpCode::LeftShift,
            Self::RightShift => OpCode::RightShift,
            Self::Cons => OpCode::Cons,
            Self::Leq => OpCode::Leq,
            Self::Lt => OpCode::Lt,
            Self::Geq => OpCode::Geq,
            Self::Gt => OpCode::Gt,
            Self::RefEq => OpCode::RefEq,
            Self::ValEq => OpCode::ValEq,
            Self::RefNeq => OpCode::RefNeq,
            Self::ValNeq => OpCode::ValNeq,
            Self::Call(..) => OpCode::Call,
            Self::Return => OpCode::Return,
            Self::Shift(..) => OpCode::Shift,
            Self::Reset => OpCode::Reset,
            Self::Jump(..) => OpCode::Jump,
            Self::JumpBack(..) => OpCode::JumpBack,
            Self::CondJump(..) => OpCode::CondJump,
            Self::CondJumpBack(..) => OpCode::CondJumpBack,
            Self::Branch => OpCode::Branch,
            Self::Fizzle => OpCode::Fizzle,
            Self::Exit => OpCode::Exit,
        }
    }
}

impl Display for Instruction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Const(value) => write!(f, "CONST {value}"),
            Self::Load => write!(f, "LOAD"),
            Self::Set => write!(f, "SET"),
            Self::Alloc => write!(f, "ALLOC"),
            Self::Free => write!(f, "FREE"),
            Self::LoadRegister(offset) => write!(f, "LOADR {offset}"),
            Self::SetRegister(offset) => write!(f, "SETR {offset}"),
            Self::Pop => write!(f, "POP"),
            Self::Swap => write!(f, "SWAP"),
            Self::Copy => write!(f, "COPY"),
            Self::Add => write!(f, "ADD"),
            Self::Subtract => write!(f, "SUB"),
            Self::Multiply => write!(f, "MUL"),
            Self::Divide => write!(f, "DIV"),
            Self::Remainder => write!(f, "REM"),
            Self::IntDivide => write!(f, "INTDIV"),
            Self::Power => write!(f, "POW"),
            Self::Negate => write!(f, "NEG"),
            Self::Glue => write!(f, "GLUE"),
            Self::Access => write!(f, "ACCESS"),
            Self::Assign => write!(f, "ASSIGN"),
            Self::Not => write!(f, "NOT"),
            Self::And => write!(f, "AND"),
            Self::Or => write!(f, "OR"),
            Self::BitwiseAnd => write!(f, "BITAND"),
            Self::BitwiseOr => write!(f, "BITOR"),
            Self::BitwiseXor => write!(f, "BITXOR"),
            Self::BitwiseNeg => write!(f, "BITNEG"),
            Self::LeftShift => write!(f, "LSHIFT"),
            Self::RightShift => write!(f, "RSHIFT"),
            Self::Cons => write!(f, "CONS"),
            Self::Leq => write!(f, "LEQ"),
            Self::Lt => write!(f, "LT"),
            Self::Geq => write!(f, "GEQ"),
            Self::Gt => write!(f, "GT"),
            Self::RefEq => write!(f, "REFEQ"),
            Self::ValEq => write!(f, "VALEQ"),
            Self::RefNeq => write!(f, "REFNEQ"),
            Self::ValNeq => write!(f, "VALNEQ"),
            Self::Call(offset) => write!(f, "CALL {offset}"),
            Self::Return => write!(f, "RETURN"),
            Self::Shift(offset) => write!(f, "SHIFT {offset}"),
            Self::Reset => write!(f, "RESET"),
            Self::Jump(offset) => write!(f, "JUMP {offset}"),
            Self::JumpBack(offset) => write!(f, "RJUMP {offset}"),
            Self::CondJump(offset) => write!(f, "JUMPF {offset}"),
            Self::CondJumpBack(offset) => write!(f, "RJUMPF {offset}"),
            Self::Branch => write!(f, "BRANCH"),
            Self::Fizzle => write!(f, "FIZZLE"),
            Self::Exit => write!(f, "EXIT"),
        }
    }
}
