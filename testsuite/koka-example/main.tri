proc xor!() {
  let p = yield 'choice
  let q = yield 'choice
  return if p then !q else q
}

proc choice!(action) {
  return with [action!()] {
    when 'choice then {
      cancel [..resume false, ..resume true]
    }
  }
}

proc surprising!() {
  let p = yield 'choice
  let i = yield 'get
  yield 'set(i + 1)
  return if i > 0 && p then xor!() else false
}

proc pstate!(init, action) {
  let mut state = init
  let result = with action!() {
    when 'get resume state
    when 'set(val) then {
      state = val
      become unit
    }
  }
  return result:state
}

proc main!() {
  assert choice!(xor) == [false, true, true, false]
  assert pstate!(0, do() choice!(surprising)) == [false, false, true, true, false]:2
  assert choice!(do() pstate!(0, surprising)) == [false:1, false:1]
  exit 0
}
