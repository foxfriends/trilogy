\subsection{Callable Types}

The remaining types are called ``callable'' types, referring to how values of these
types are used by calling them.

All callable types are non-structural and reference types. Callable types do
have string and source representations, but in versions prior to the 1.0
release of \Trilogy{}, converting to source representation of these types will
not be officially defined or supported.

\subsubsection{Functions}

The Function type is a callable type, which is the type of defined functions and
function closures, as well as procedures and procedure closures.

In type annotation, the Function type is written in one of two ways.
For functions of arity one we write \texttt{T -> U}, whereas for functions of arity
other than one we write, for example \texttt{!(A, B, C) -> U}.

A value of the Function type with arity one may be applied by providing its argument
directly after, separated only by a space. Values of the Function type with any arity,
including one, may be called using the procedure call syntax \texttt{!()},
passing arguments to all of the defined parameters within the parentheses.

The string representation of a defined (named) function is its name. Meanwhile, the
string representation of an anonymous function closure is defined to be the literal
string \texttt{<fn>}.

\subsubsection{Queries}

The Query type is a callable type, which is the type of defined rules and query
closures.

In type annotation, the Query type is written as \texttt{?(T, U)}. Notably, the
Query type does not return any value. Instead, values of the Query type are
``called'' in binding position, where their parameters are treated both as
input expressions and output patterns.

The string representation of a defined (named) query is its name. Meanwhile, the
string representation of an anonymous query closure is defined to be the literal
string \texttt{<qy>}.

\subsubsection{Continuations}

Very similar to the Function type is the Continuation type. Conceptually, a continuation
may actually just \emph{be} a function, and indeed when written as a type annotation, it
is written the same as a function (e.g. \texttt{T -> U}).

The difference is mostly one of implementation, as a continuation is not constructed in
the same way as a function, but can only be acquired by reference to a first class keyword.

Continuations are applied much like functions, and may evaluate to some value just as a
function application does.

The string representation of a continuation depends on which keyword was captured to
reify that continuation, but is one of the literal strings \texttt{<resume>}, \texttt{<cancel>},
\texttt{<break>}, \texttt{<continue>}, or \texttt{<return>}.

\subsubsection{Modules and Module Functions}

Modules and Module Functions in \Trilogy{} are first class objects which behave much
like values of Record or Function type. While they may be passed as arguments
to other procedures and functions, Module Functions are restricted to accepting other
Modules (and Module Functions) as parameters, ensuring that all module lookups can be
performed statically.

At this time, a Module allows you to implement the closest thing to what you might
consider an abstract data type in another language. A Module Function could be considered
as a generic data type, where the expected signatures of its parameters are like interfaces that
other modules may implement. None of that requires particular handling in the type system
however, as modules are restricted to being applied statically.

In type annotation, the module type is written as \texttt{Module}, and a module function
as \texttt{T -> Module}. This is not exactly the most strongly typed of descriptors,
but suffices for the purposes of \Trilogy{} as a dynamically typed language. While it may
be useful at times to be able to describe the signature of these modules, in practice it
is unnecessary as the interpreter will be able to determine statically whether a module
call is valid or not.

That said, modules can still be converted to string representation, which is the
of the module followed by the string representations of its parameters, if any
such as \texttt{ModuleA 1 (ModuleB 2 3)}.
