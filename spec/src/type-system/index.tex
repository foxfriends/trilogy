\section{Type System}

\Trilogy{} is (currently) a dynamically typed language; all types are determined
and checked at runtime. Recall that ``dynamically typed'' is not the absence of
a type system, but the presence of a type system so complex that it cannot be
fully statically analyzed.

Despite the lack of static analysis, we attempt to fully specify the type system
of \Trilogy{} in hopes that someday it can be statically analyzed (an attempt at
(potentially optional) static (higher-kinded? dependent?) typing is on the long
term roadmap).

Worth mentioning is that the type system of \Trilogy{} spans all sub-languages
consistently. The syntax and behaviour of all data types are the same, no matter
where they are being used. The types are summarized below, with exact specifications
of the operators come later, in Syntax and Semantics (\S\ref{sec:syntax})

\subsection{Built-In Types}

There are 5 primitive data types in \Trilogy{}:

\begin{itemize}
    \item Never
    \item Unit
    \item Boolean
    \item Atom
    \item Character
    \item String
    \item Number
\end{itemize}

\noindent
There are also 5 compound types, which may be constructed out of primitives
and other types:

\begin{itemize}
    \item Labelled
    \item Tuple
    \item Array
    \item Set
    \item Record
    \item Iterator
\end{itemize}

\noindent
Defined items (and their locally defined counterparts) are also values which
have types:

\begin{itemize}
    \item Procedure
    \item Procedure Closure
    \item Function
    \item Function Closure
    \item Rule
    \item Ruleset
    \item Continuation
    \item Module
    \item Module Function
\end{itemize}

\noindent
There are no explicit user defined types, only combinations of the built in
types, so this is a complete list of all types to be seen in a \Trilogy{}
program.

By no means, however, is this the end of the story for \Trilogy{}'s type
system. Custom data types, as well as further built-in primitive types are,
are on the list of things to implement once the language is in a functioning
state.

\subsubsection{Structural Types}

Structural types are types which have a ``physical'' structure, which may be
interpreted intuitively. Structural types may be destructured using pattern
matching, and are compared structurally (deeply) using the structural equality
operator (\kw{is}).

\subsubsection{Reference Types}

Reference types are those which are stored and passed by \emph{reference}. When
a value of a reference type is passed as an argument or a assigned to a variable, both
variables refer to the same \emph{instance} of that value. When dealing with
mutation of an instance with multiple references, modifications made to any
reference to that instances are reflected in all other references. This should be
intuitive to users of Javascript, which follows similar reference semantics.

When comparing reference types, there are two options. The referential equality
operator (\op{==)} will compare the values by reference first; that is, if
both values are of a reference type, they are considered equal if and only
if they are references to the same instance. If either value is not a reference
type, they will be compared structurally. In contrast, the structural equality
operator (\kw{is}) will compare structurally first: if both values are structural
types, they will be compared structurally, otherwise they will be compared by
reference.

Some types are both structural and reference types.

\input{primitives.tex}

\input{compound-types.tex}
