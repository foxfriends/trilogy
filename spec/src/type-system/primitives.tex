\subsection{Primitive Types}

There's not much interesting to be said about primitives. These types are
backed directly by counterparts in the interpreter's implementation language,
and so cannot be further broken down in exchange for performance closer to
that of native code on their basic operations.

All primitive types are structural types, no primitive types are reference
types.

\subsubsection{Never}

Never is a type with no values. While not particularly useful as a value,
Never is the type of a \kw{return} statement, as well as the type of
a \kw{yield} that is not \kw{resume}d, and of actions which terminate the
program, such as calling \fn{exit!}.

\subsubsection{Unit}

Unit is a type with a single-value, the literal \kw{unit}. Unit on its own
has no particular meaning, but it can be used to signal the lack of value.

This is the type returned by functions or procedures which do not return
any other value. Within the standard library, Unit is used as the sentinel
value for the end of a list.

The string representation of Unit is \texttt{unit}.

\subsubsection{Boolean}

Boolean is a type with two values, the literals \kw{true} and \kw{false},
which act much like they do in every language I can think of.

Boolean values are the result of many comparisons (such as \op{lt} and
\op{gt}), can be manipulated by the Boolean operators (\kw{and}, \kw{or},
and \kw{not}) and are used by control flow constructs (\kw{if} and
\kw{while}).

The string representation of the Boolean values
\kw{true} and \kw{false} are \texttt{true} and \texttt{false},
respectively.

\subsubsection{Atom}

Atom is a type which typically exist in finite quantities. Any individual
Atom has no value on its own, but its literal form may hint to a reader at
what its value is meant to signal. The only real operation available for
Atom values is equality, which is performed in $O(1)$ time.

An Atom literal is an identifier prefixed with a single quote (\texttt{'}).
Within the standard library, some Atoms yielded as effects to signal
exceptional situations:

\begin{itemize}
    \item \val{'NAN}: yielded by Number parsing functions when the value
    cannot be parsed as a Number.
    \item \val{'EOF}: yielded by input procedures when the end of input
    has been reached.
\end{itemize}

The string representation of an Atom is its symbol without the single quote
(i.e. \val{'NAN} as a string is \texttt{NAN}).

\subsubsection{Character}

The Character type is used to represent individual Unicode code points,
a Character value representing exactly one.

Internally, Characters are represented using their UTF-8 encodings. Characters
can safely be converted to Numbers, as every Character's UTF-8 encoding is a valid
Number. Meanwhile, not every Number may be safely converted to a Character,
as not every binary sequence represents a valid UTF-8 codepoint.

Character literals are specified as a single UTF-8 code point between
single quotes. Alternatively, an escape sequence (\S\ref{sec:escapesequences})
may be used to represent an ASCII or Unicode character code by its hexadecimal
representation, or one of the specially supported common escape sequences.

The string representation of a Character is a String containing that one
Character. Some examples:

\begin{table}[H]
    \centering
    \begin{tabular}{ll}
        \hline
        \textbf{Source} & \textbf{String} \\
        \hline
        \val{'c'} & \texttt{c} \\
        \val{'\textbackslash t'} & \emph{Line break}\\
        \val{'\textbackslash x65'} & \texttt{e} \\
        \val{'\textbackslash u\{03BB\}} & \texttt{$\lambda$} \\
        \hline
    \end{tabular}
\end{table}

\subsubsection{String}

The String type is a sequence of Characters. This sounds somewhat like
a composite type, but since a String can only contain Characters and has
its own literal format, it is practically more like a primitive.

Strings may be manipulated using the push operator (\op{+}) to attach a
Character to a String, and the glue operator (\op{<>}) to attach two
Strings together. The indexing operator (\op{.[]}) may also be used to
access a Character at a particular index.

String literals are represented using double quotes. Additionally,
untagged template literals produce Strings by using the natural
string representation of the interpolated values.

The string representation of a String is the string itself.

\subsubsection{Number}

The Number type is used to represent numbers, on which mathematical
operations can be performed. In \Trilogy{}, numbers go beyond integers
and floating point numbers to also include any rational or complex
numbers as well.

These numbers support all the normal operations (addition \op{+},
subtraction \op{-}, multiplication \op{*}, division \op{/},
modulus \op{\%}, integer division \op{//}, power \op{**}), but
division is perfect (\texttt{1 / 3 == 1/3}), and operations that
require complex numbers (\texttt{(-1) ** 1/2 == 0i1}) will succeed.

This does come at the cost of slower mathematical operations, and a
more questionable binary representation of non-integer values. Bitwise
operations (and \op{\&}, or \op{|}, xor \op{\textasciicircum}, not
\op{\textasciitilde}, shift \op{\textasciitilde>} and \op{<\textasciitilde})
will act as expected on integers, whose binary representation is
standard, but will fail on non-integer values. As Numbers are unbounded,
the shift operators will never wrap around nor truncate.

The string representation of a Number depends on the value of the number,
and is most conveniently described by example:

\begin{table}[H]
    \centering
    \begin{tabular}{rr}
        \hline
        \textbf{Source} & \textbf{String} \\
        \hline
        \val{123} & \texttt{123} \\
        \val{-123} & \texttt{-123} \\
        \val{123.456} & \texttt{123.456} \\
        \val{-123.456} & \texttt{-123.456} \\
        \val{1/3} & \texttt{1/3} \\
        \val{-1/3} & \texttt{-1/3} \\
        \val{123i456} & \texttt{123 + 456i} \\
        \val{123 - 0i456} & \texttt{123 - 456i} \\
        \val{123.5i5.4} & \texttt{123.5 + 5.4i} \\
        \hline
    \end{tabular}
\end{table}

\noindent
There are some cases missing, but hopefully they are easy to extrapolate.
