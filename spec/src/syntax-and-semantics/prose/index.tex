\subsection{Prose}

When viewed on its own, \Prose{} has a fairly ``standard'' C-family syntax.
Arbitrary patterns are permitted in the procedure heads.
Trailing commas are permitted in all places where commas are found.

\begin{bnf*}
    \bnfprod{ProcedureHead}{
        \bnfts{IdentiferBang}
        \bnfsp
        \bnfts{(}
        \bnfsp
        \bnfpn{ParameterList}
        \bnfsp
        \bnfts{)}
    } \\
    \bnfprod{ParameterList}{
        \bnfpn{Pattern}
        \bnfsp
        \bnfts{,}
        \bnfsp
        \bnfpn{ParameterList}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{Pattern}
        \bnfor
        \bnfes
    }
\end{bnf*}

\noindent A procedure declaration binds the name in the scope of the current module.
As with all kinds of declarations in \Trilogy{}, procedure declarations may be
referenced out of order.

When called, the body of the procedure is run with the formal parameters bound to
the arguments with which the procedure was called. A procedure may use the \kw{return}
keyword to end its evaluation, with its call evaluating to the returned value.
If control runs off the end of the procedure's body, its call evaluates to \kw{unit}.

It is also possible for a procedure to never return, such as the built-in \fn{exit!},
in which case the return type is Never and such a value may never be realized.

\begin{prooftree}
    \def\defaultHypSeparation{\hskip 0pt}
    \AxiomC{$\kw{proc}\ p\texttt{!}(x_{1\hdots n})\ \{\ M,\ \kw{return}\ N\ \}$}
    \AxiomC{$\Gamma,x_{1\hdots n}:\tau_{1\hdots n},M \vdash N : \tau$}
    \LeftLabel{Procedure\textsuperscript{ret}}
    \BinaryInfC{$\Gamma \vdash p: \texttt{!(}\tau_{1\hdots n}\texttt{)}\rightarrow\tau$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\kw{proc}\ p\texttt{!}(x_{1\hdots n})\ \{\ M\ \}$}
    \AxiomC{$\Gamma,x_{1\hdots n}:\tau_{1\hdots n} \vdash M : \top$}
    \LeftLabel{Procedure\textsuperscript{$\top$}}
    \BinaryInfC{$\Gamma \vdash p: \texttt{!(}\tau_{1\hdots n}\texttt{)}\rightarrow\kw{unit}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\kw{proc}\ p\texttt{!}(x_{1\hdots n})\ \{\ M\ \}$}
    \AxiomC{$\Gamma,x_{1\hdots n}:\tau_{1\hdots n} \vdash M : \bot$}
    \LeftLabel{Procedure\textsuperscript{$\bot$}}
    \BinaryInfC{$\Gamma \vdash p:\ \texttt{!(}\tau_{1\hdots n}\texttt{)}\rightarrow\bot$}
\end{prooftree}

\subsubsection{Sequences}

The body of a procedure is a sequence of statements. Statements in sequence
must be separated by a line break or an explicit separator (\op{,}).

\begin{bnf*}
    \bnfprod{ProcedureBody}{\bnfpn{Sequence}} \\
    \bnfprod{Sep}{\bnfpn{EOL}\bnfor\bnfts{,}} \\
    \bnfprod{Sequence}{\bnfpn{Statement}\bnfsp\bnfpn{Sep}\bnfsp\bnfpn{Sequence}\bnfor} \\
    \bnfmore{\bnfpn{Statement}\bnfor\bnfes}
\end{bnf*}

A sequence of statements has no value, but rather each step of the sequence
performs some effect on the context in which it is being run, eventually
producing the result of the program.

\begin{prooftree}
    \AxiomC{$\Gamma \vdash M \Rightarrow \Phi$}
    \AxiomC{$\Phi \vdash N : \tau$}
    \LeftLabel{Sequence\textsuperscript{$\top$}}
    \BinaryInfC{$\Gamma \vdash M \op{,}\ N: \tau$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash M \Rightarrow \bot$}
    \LeftLabel{Sequence\textsuperscript{$\bot$}}
    \UnaryInfC{$\Gamma \vdash M \op{,}\ N: \bot$}
\end{prooftree}

\subsubsection{Statements}

A statement is a single ``step'' of a procedure in \Prose{}. Statements do not
evaluate to any value, but they perform effects on the state of the program and
its environment.

To differentiate with similar constructs in \Poetry{}, while also saving space,
the names of the statement productions are prefixed with S, short for statement.
Meanwhile, expressions are actually all \Poetry{}, so such specification is left
until later.

\begin{bnf*}
    \bnfprod{Statement}{
        \bnfpn{SLet}
        \bnfor
        \bnfpn{SAssignment}
        \bnfor
        \bnfpn{SIfElse}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{SMatch}
        \bnfor
        \bnfpn{SFor}
        \bnfor
        \bnfpn{SWhile}
        \bnfor
        \bnfpn{SLoop}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{SBreak}
        \bnfor
        \bnfpn{SContinue}
        \bnfor
        \bnfpn{SReturn}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{SYield}
        \bnfor
        \bnfpn{ProcedureCall}
        \bnfor
        \bnfpn{Block}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{ParenthesizedExpression}
    } \\
    \bnfprod{ParenthesizedExpression}{
        \bnfts{(}
        \bnfsp
        \bnfpn{Expression}
        \bnfsp
        \bnfts{)}
    } \\
    \bnfprod{Block}{
        \bnfts{\{}
        \bnfsp
        \bnfpn{Sequence}
        \bnfsp
        \bnfts{\}}
    }
\end{bnf*}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash M : \tau$}
    \LeftLabel{Unwrap}
    \UnaryInfC{$\Gamma \vdash \texttt{(}\ M\ \texttt{)} : \top$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma :> \Phi$}
    \AxiomC{$\Phi \vdash M : \tau$}
    \LeftLabel{Unnest}
    \BinaryInfC{$\Gamma \vdash \texttt{\{}\ M\ \texttt{\}} : \tau$}
\end{prooftree}

\subsubsection{Let}

The \kw{let} statement in \Prose{} exposes a ``default binding context'' in which
bindings may be introduced. Depending on how many times the binding pattern matches,
this may introduce a branch or cause a fizzle. Most often, however, such bindings
are deterministic and so control flow will progress intuitively.

There are two forms to a \kw{let} statement: the common unification case,
and the more general \Law{} rule lookup case.

\begin{bnf*}
    \bnfprod{SLet}{
        \bnfts{\kw{let}}
        \bnfsp
        \bnfpn{Pattern}
        \bnfsp
        \bnfts{\op{=}}
        \bnfsp
        \bnfpn{Expression}
        \bnfor
    } \\
    \bnfmore{
        \bnfts{\kw{let}}
        \bnfsp
        \bnfpn{Lookup}
    }
\end{bnf*}

Semantically, a \kw{let} statement introduces an implicit scope from its location
in the source code until the end of the nearest explicit scope (e.g. the end of a block).
The bindings declared in this statement are available within that scope.

\begin{prooftree}
    \AxiomC{$\Gamma \vdash y$}
    \AxiomC{$x = y$}
    \AxiomC{$\Gamma, \{ a\ |\ a := x \} :> \Phi$}
    \LeftLabel{\label{sem:declaration}Declare}
    \TrinaryInfC{$\Gamma \vdash \kw{let}\ x = y \Rightarrow \Phi$}
\end{prooftree}

What is more unique to \Trilogy{} is the branching and fizzling capability of the
\kw{let} statement when provided a lookup of a rule of \Law{}. Depending on
how many possible bindings there are for the provided rule, a \kw{let} statement
may lead to multiple executions of the program running in parallel, or none.

\begin{prooftree}
    \AxiomC{$\Gamma \vdash y$}
    \AxiomC{$x = y$}
    \AxiomC{$\Gamma, \{ a\ |\ a := x \} :> \Phi$}
    \LeftLabel{Branch}
    \TrinaryInfC{$\Gamma \vdash \kw{let}\ x \Rightarrow \Phi$}
\end{prooftree}

Notably, the semantics are nearly the same, the only difference is that in the
binding case $y$ is determined contextually (leading to its multiple possibilities)
whereas, in the declaration case, the single value of $y$ was noted in the source
code leading to the typical at-most-once binding behaviour found in most programming
languages. The declaration case may still fail to bind, leading to a fizzle.

% NOTE: in process of reconsidering. Below is not likely accurate.

\subsubsection{Assignment}

Variables (specifically, mutable bindings) may be assigned to. Similar to
declaration via \kw{let}, the left-hand side of standard assignment may be
any pattern that does not introduce \emph{new} bindings. The pattern may only
use previously bound names.

Function assignment is a special syntax for applying a function to a value and
then simultaneously reassigning that value with the result of the function; a
generalization of operators like \op{+=} to any function. In this form of assignment,
the left-hand side of the assignment operator is a single identifier, and the right
side is the arguments to apply to the function being used as the assignment operator.
The left hand side is then applied as the last argument to the function.

Regular operator assignment (\op{+=}, \op{-=}, etc.) is supported as well, in the
intuitive way (the left hand identifer is used as the left hand side of the operator).

\begin{bnf*}
    \bnfprod{SAssignment}{
        \bnfpn{PatternAssignment}
        \bnfor
        \bnfpn{FunctionAssignment}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{OperatorAssignment}
    } \\
    \bnfprod{PatternAssignment}{
        \bnfpn{Pattern}
        \bnfsp
        \bnfts{\op{=}}
        \bnfsp
        \bnfpn{Expression}
    } \\
    \bnfprod{FunctionAssignment}{
        \bnfpn{Identifier}
        \bnfsp
        \bnfts{IdentifierEq}
        \bnfsp
        \bnfpn{ApplicationList}
    } \\
    \bnfprod{OperatorAssignment}{
        \bnfpn{Identifier}
        \bnfsp
        \bnfpn{OperatorEq}
        \bnfsp
        \bnfpn{Expression}
    } \\
    \bnfprod{OperatorEq}{
        \bnfts{+=}\bnfor
        \bnfts{-=}\bnfor
        \bnfts{*=}\bnfor
        \bnfts{/=}\bnfor
        \bnfts{\%=}\bnfor
        \bnfts{**=}\bnfor
        \bnfts{//=}\bnfor
        \bnfts{<>=}\bnfor
    } \\
    \bnfmore{
        \bnfts{|=}\bnfor
        \bnfts{\&=}\bnfor
        \bnfts{\textasciicircum=}\bnfor
        \bnfts{\textasciitilde=}\bnfor
        \bnfts{<\textasciitilde=}\bnfor
        \bnfts{\textasciitilde>=}
    }
\end{bnf*}

\begin{prooftree}
    \def\defaultHypSeparation{\hskip 0.05in}
    \AxiomC{$\Gamma \vdash y:\pi$}
    \AxiomC{$y = x$}
    \AxiomC{$\Gamma \vdash \{a : \pi_i\ |\ a := x\ \}$}
    \AxiomC{$\Gamma,a:\pi_i \vdash M : \tau$}
    \LeftLabel{Assignment}
    \QuaternaryInfC{$\Gamma\vdash x\ \op{=}\ y\op{,}\ M : \tau$}
\end{prooftree}

Rather than defining the exact semantics of function or operator assignment,
instead understand those by syntax transformation, and use the same assignment
semantics as normal:

\begin{align*}
    \texttt{\$x:id \$fn:id= \$(\$a:expr)+} &\Rightarrow \texttt{\$x = \$f \$(\$a)+ \$x} \\ %
    \texttt{\$x:id \$op:op= \$a:expr} & \Rightarrow \texttt{\$x = \$x \$op \$a} %
\end{align*}

\subsubsection{Conditionals}

The conditional statement in \Trilogy{} comes in the form of \kw{if}-\kw{else}
chains. For \Prose{} they are defined as follows.

\begin{bnf*}
    \bnfprod{SIfElse}{
        \bnfts{\kw{if}}
        \bnfsp
        \bnfpn{Condition}
        \bnfsp
        \bnfpn{Block}
        \bnfsp
        \bnfpn{SElseChain}
        \bnfor
    } \\
    \bnfprod{SElseChain}{
        \bnfts{\kw{else}}
        \bnfsp
        \bnfts{\kw{if}}
        \bnfsp
        \bnfpn{Condition}
        \bnfsp
        \bnfpn{Block}
        \bnfsp
        \bnfpn{SElseChain}
        \bnfor
    } \\
    \bnfmore{
        \bnfts{\kw{else}}
        \bnfsp
        \bnfpn{Block}
        \bnfor
        \bnfes
    }
\end{bnf*}

In the common case, the condition is a statement that evaluates to a Boolean
result, \kw{true} or \kw{false}, and control flows as you might expect.
If the result is not a Boolean, the execution fizzles.

An \kw{if}-\kw{else} chain evaluates to the value of the block that is executed.
If no block is executed (there is no \kw{else} clause, and none of the
conditions matched) the resulting value is \kw{unit}.

\begin{prooftree}
    \AxiomC{$C : \kw{true}$}
    \AxiomC{$T : \tau_1$}
    \AxiomC{$F : \tau_2$}
    \LeftLabel{Branch Hit\textsuperscript{A}}
    \TrinaryInfC{$\kw{if}\ C\ T\ \kw{else}\ F : \tau_1$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$C : \kw{false}$}
    \AxiomC{$T : \tau_1$}
    \AxiomC{$F : \tau_2$}
    \LeftLabel{Branch Miss\textsuperscript{A}}
    \TrinaryInfC{$\kw{if}\ C\ T\ \kw{else}\ F : \tau_2$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$C : \kw{true}$}
    \AxiomC{$T : \tau$}
    \LeftLabel{Branch Hit\textsuperscript{B}}
    \BinaryInfC{$\kw{if}\ C\ T : \tau$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$C : \kw{false}$}
    \AxiomC{$T : \tau$}
    \LeftLabel{Branch Miss\textsuperscript{B}}
    \BinaryInfC{$\kw{if}\ C\ T : \kw{unit}$}
\end{prooftree}

In addition to Boolean evaluations, Conditions may be queries which bind
values to names available for the scope of the block of the first matching
condition. This is similar to the \texttt{if let} statement seen in other
languages, but extended to cover more than just pattern matching by taking
advantage of \Law{}. Conditions may not be empty, but trailing commas are
still supported, so we end up with this annoying extra bit of rule.

\begin{bnf*}
    \bnfprod{Condition}{
        \bnfpn{Expression}
        \bnfsp
        \bnfts{,}
        \bnfsp
        \bnfpn{Condition}
        \bnfor
        \bnfpn{Query}
        \bnfsp
        \bnfts{,}
        \bnfsp
        \bnfpn{Condition}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{Expression}
        \bnfsp
        \bnfts{,}
        \bnfor
        \bnfpn{Query}
        \bnfsp
        \bnfts{,}
        \bnfor
        \bnfpn{Expression}
        \bnfor
        \bnfpn{Query}
    } \\
    \bnfprod{Query}{
        \bnfpn{Pattern}
        \bnfsp
        \bnfts{=}
        \bnfsp
        \bnfpn{Expression}
        \bnfor
        \bnfpn{RuleCheck}
    }
\end{bnf*}

A conditional is not an iterative context. If a pattern condition matches
to multiple results, the first result is chosen and the rest are skipped.
