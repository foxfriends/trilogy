\subsection{Prose}

When viewed on its own, \Prose{} has a fairly ``standard'' C-family syntax.
Arbitrary patterns are permitted in the procedure heads.
Trailing commas are permitted in all places where commas are found.

\begin{bnf*}
    \bnfprod{ProcedureHead}{
        \bnfts{IdentiferBang}
        \bnfsp
        \bnfts{(}
        \bnfsp
        \bnfpn{ParameterList}
        \bnfsp
        \bnfts{)}
    } \\
    \bnfprod{ParameterList}{
        \bnfpn{Pattern}
        \bnfsp
        \bnfts{,}
        \bnfsp
        \bnfpn{ParameterList}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{Pattern}
        \bnfor
        \bnfes
    }
\end{bnf*}

\noindent A procedure declaration binds the name in the scope of the current module.
As with all kinds of declarations in \Trilogy{}, procedure declarations may be
referenced out of order.

When called, the body of the procedure is run with the formal parameters bound to
the arguments with which the procedure was called. A procedure may use the \kw{return}
keyword to end its evaluation, with its call evaluating to the returned value.
If control runs off the end of the procedure's body, its call evaluates to \kw{unit}.
A procedure may cause a fizzle or branch, in which case all evaluations are propgated
to the call site, conceptually causing the call to fizzle or branch respectively.

It is also possible for a procedure to never return, yet also not cause a fizzle,
such as the built-in \fn{exit!}, in which case the return type is Never and such a
value may never be realized.

\begin{prooftree}
    \AxiomC{$\kw{proc}\ p\texttt{!}(x_{1\hdots n})\ \{\ M,\ \kw{return}\ N\ \}$}
    \AxiomC{$\Gamma,x_{1\hdots n} \vdash M\op{,}\ N $}
    \LeftLabel{Procedure}
    \BinaryInfC{$\Gamma \vdash p\texttt{!(}x_{1\hdots n}\texttt{)}=N$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\kw{proc}\ p\texttt{!}(x_{1\hdots n})\ \{\ M\ \}$}
    \AxiomC{$\Gamma,x_{1\hdots n} \vdash M : \top$}
    \LeftLabel{Procedure\textsuperscript{$\top$}}
    \BinaryInfC{$\Gamma \vdash p\texttt{!(}x_{1\hdots n}\texttt{)}=\kw{unit}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\kw{proc}\ p\texttt{!}(x_{1\hdots n})\ \{\ M\ \}$}
    \AxiomC{$\Gamma,x_{1\hdots n} \vdash M : \bot$}
    \LeftLabel{Procedure\textsuperscript{$\bot$}}
    \BinaryInfC{$\Gamma \vdash p\texttt{!(}x_{1\hdots n}\texttt{)}:\bot$}
\end{prooftree}

\subsubsection{Sequences}

The body of a procedure is a sequence of statements. Statements in sequence
must be separated by a line break or an explicit separator (\op{,}).

\begin{bnf*}
    \bnfprod{ProcedureBody}{\bnfpn{Sequence}} \\
    \bnfprod{Sep}{\bnfpn{EOL}\bnfor\bnfts{,}} \\
    \bnfprod{Sequence}{\bnfpn{Statement}\bnfsp\bnfpn{Sep}\bnfsp\bnfpn{Sequence}\bnfor} \\
    \bnfmore{\bnfpn{Statement}\bnfor\bnfes}
\end{bnf*}

A sequence of statements has no value, but rather each step of the sequence
performs some effect on the context in which it is being run, eventually
producing the result of the program.

\begin{prooftree}
    \AxiomC{$\Gamma \vdash M \Rightarrow \Phi$}
    \AxiomC{$\Phi \vdash N : \tau$}
    \LeftLabel{Sequence\textsuperscript{$\top$}}
    \BinaryInfC{$\Gamma \vdash M \op{,}\ N: \tau$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash M \Rightarrow \bot$}
    \LeftLabel{Sequence\textsuperscript{$\bot$}}
    \UnaryInfC{$\Gamma \vdash M \op{,}\ N: \bot$}
\end{prooftree}

\subsubsection{Statements}

A statement is a single ``step'' of a procedure in \Prose{}. Statements do not
evaluate to any value, but they perform effects on the state of the program and
its environment.

To differentiate with similar constructs in \Poetry{}, while also saving space,
the names of the statement productions are prefixed with S, short for statement.
Meanwhile, expressions are actually all \Poetry{}, so such specification is left
until later.

\begin{bnf*}
    \bnfprod{Statement}{
        \bnfpn{SLet}
        \bnfor
        \bnfpn{SAssignment}
        \bnfor
        \bnfpn{SIfElse}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{SMatch}
        \bnfor
        \bnfpn{SWhile}
        \bnfor
        \bnfpn{SFor}
        \bnfor
        \bnfpn{SLoop}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{SBreak}
        \bnfor
        \bnfpn{SContinue}
        \bnfor
        \bnfpn{SReturn}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{SYield}
        \bnfor
        \bnfpn{ProcedureCall}
        \bnfor
        \bnfpn{Block}
        \bnfor
    } \\
    \bnfmore{
        \bnfts{(}
        \bnfsp
        \bnfpn{Expression}
        \bnfsp
        \bnfts{)}
    } \\
    \bnfprod{Block}{
        \bnfts{\{}
        \bnfsp
        \bnfpn{Sequence}
        \bnfsp
        \bnfts{\}}
    }
\end{bnf*}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash M : \tau$}
    \LeftLabel{Unwrap}
    \UnaryInfC{$\Gamma \vdash \texttt{(}\ M\ \texttt{)} : \top$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma :> \Phi$}
    \AxiomC{$\Phi \vdash M : \tau$}
    \LeftLabel{Unnest}
    \BinaryInfC{$\Gamma \vdash \texttt{\{}\ M\ \texttt{\}} : \tau$}
\end{prooftree}

\subsubsection{Let}

The \kw{let} statement in \Prose{} exposes a ``binding context'' in which
bindings may be introduced, similar to that of \Law{}. Depending on how many times
the binding pattern matches, this may introduce a branch or cause a fizzle.
Most often, however, such bindings are done via a direct single unification
which is determinisitic, and so control flow will progress intuitively.

\begin{bnf*}
    \bnfprod{SLet}{
        \bnfts{\kw{let}}
        \bnfsp
        \bnfpn{Unification}
    } \\
\end{bnf*}

Semantically, a \kw{let} statement introduces an implicit scope from its location
in the source code until the end of the nearest explicit scope (e.g. the end of a block).
The bindings declared in this statement are available within that scope.

What is more unique to \Trilogy{} is the branching and fizzling capability of the
\kw{let} statement when provided a unification via a more complex rule of \Law{}.
Depending on how many possible bindings there are for the provided rule, a \kw{let}
statement may lead to multiple executions of the program running in parallel, or none.

\begin{prooftree}
    \AxiomC{$\Gamma \vdash U \Rightarrow \Phi$}
    \LeftLabel{Branch}
    \UnaryInfC{$\Gamma \vdash \kw{let}\ U \Rightarrow \Phi$}
\end{prooftree}

\subsubsection{Assignment}

Variables (specifically, mutable bindings) may be assigned to. Similar to
declaration via \kw{let}, the left-hand side of standard assignment may be
any pattern so long as it does not introduce new bindings. The pattern may only
use previously bound names. The assignment statement updates the values of the
bindings in the pattern.

Function assignment is a special syntax for applying a function to a value and
then simultaneously reassigning that value with the result of the function; a
generalization of operator assignment (e.g. \op{+=}) to any function. In this form
of assignment, the left-hand side of the assignment operator is a single identifier,
and the right side is the arguments to apply to the function being used as the
assignment operator. The left hand side is then applied as the last argument to
the function.

Regular operator assignment (\op{+=}, \op{-=}, etc.) is supported as well, in the
intuitive way: the left hand identifer is used as the left hand side of the operator.

\begin{bnf*}
    \bnfprod{SAssignment}{
        \bnfpn{PatternAssignment}
        \bnfor
        \bnfpn{FunctionAssignment}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{OperatorAssignment}
    } \\
    \bnfprod{PatternAssignment}{
        \bnfpn{Pattern}
        \bnfsp
        \bnfts{\op{=}}
        \bnfsp
        \bnfpn{Expression}
    } \\
    \bnfprod{FunctionAssignment}{
        \bnfpn{Identifier}
        \bnfsp
        \bnfts{IdentifierEq}
        \bnfsp
        \bnfpn{ApplicationList}
    } \\
    \bnfprod{OperatorAssignment}{
        \bnfpn{Identifier}
        \bnfsp
        \bnfpn{OperatorEq}
        \bnfsp
        \bnfpn{Expression}
    } \\
    \bnfprod{OperatorEq}{
        \bnfts{+=}\bnfor
        \bnfts{-=}\bnfor
        \bnfts{*=}\bnfor
        \bnfts{/=}\bnfor
        \bnfts{\%=}\bnfor
        \bnfts{**=}\bnfor
        \bnfts{//=}\bnfor
        \bnfts{<>=}\bnfor
    } \\
    \bnfmore{
        \bnfts{|=}\bnfor
        \bnfts{\&=}\bnfor
        \bnfts{\textasciicircum=}\bnfor
        \bnfts{\textasciitilde=}\bnfor
        \bnfts{<\textasciitilde=}\bnfor
        \bnfts{\textasciitilde>=}
    }
\end{bnf*}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash y$}
    \AxiomC{$P = y$}
    \AxiomC{$\Gamma, \{a\ |\ a := P\} :> \Phi$}
    \LeftLabel{Assignment}
    \TrinaryInfC{$\Gamma\vdash P\ \op{=}\ y \Rightarrow \Phi$}
\end{prooftree}

Rather than defining the exact semantics of function or operator assignment,
instead understand those by syntax transformation, and use the same assignment
semantics as normal:

\begin{align*}
    \texttt{\$x:id \$fn:id= \$(\$a:expr)+} &\Rightarrow \texttt{\$x = \$f \$(\$a)+ \$x} \\ %
    \texttt{\$x:id \$op:op= \$a:expr} & \Rightarrow \texttt{\$x = \$x \$op \$a} \\ %
\end{align*}

\subsubsection{Conditionals}

The primary conditional statement in \Prose{} is the \kw{if} statement,
which appears as you might expect coming from nearly any other language.

\begin{bnf*}
    \bnfprod{SIfElse}{
        \bnfts{\kw{if}}
        \bnfsp
        \bnfpn{Expression}
        \bnfsp
        \bnfpn{Block}
        \bnfsp
        \bnfpn{SElseChain}
        \bnfor
    } \\
    \bnfprod{SElseChain}{
        \bnfts{\kw{else}}
        \bnfsp
        \bnfts{\kw{if}}
        \bnfsp
        \bnfpn{Expression}
        \bnfsp
        \bnfpn{Block}
        \bnfsp
        \bnfpn{SElseChain}
        \bnfor
    } \\
    \bnfmore{
        \bnfts{\kw{else}}
        \bnfsp
        \bnfpn{Block}
        \bnfor
        \bnfes
    }
\end{bnf*}

In the common case, the condition is a statement that evaluates to a Boolean
result, \kw{true} or \kw{false}, and control flows as you might expect.
If the result is not a Boolean, the execution fizzles.

\begin{prooftree}
    \AxiomC{$\Gamma \vdash C = \kw{true}$}
    \AxiomC{$\Gamma \vdash T \Rightarrow \Phi$}
    \LeftLabel{If Else\textsuperscript{\kw{true}}}
    \BinaryInfC{$\Gamma \vdash \kw{if}\ C\ T\ \kw{else}\ F \Rightarrow \Phi$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma \vdash C = \kw{false}$}
    \AxiomC{$\Gamma \vdash F \Rightarrow \Phi$}
    \LeftLabel{If Else\textsuperscript{\kw{false}}}
    \BinaryInfC{$\Gamma \vdash \kw{if}\ C\ T\ \kw{else}\ F \Rightarrow \Phi$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma \vdash C = \kw{true}$}
    \AxiomC{$\Gamma \vdash T \Rightarrow \Phi$}
    \LeftLabel{If\textsuperscript{\kw{true}}}
    \BinaryInfC{$\Gamma \vdash \kw{if}\ C\ T \Rightarrow \Phi$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma \vdash C = \kw{false}$}
    \LeftLabel{If\textsuperscript{\kw{false}}}
    \UnaryInfC{$\Gamma \vdash \kw{if}\ C\ T : \top$}
\end{prooftree}

\subsubsection{Match}

The \kw{match} statement allows for pattern matching, allowing code to branch
on the structure of a value, rather than a Boolean evaluation of an expression.
As \Trilogy{} is a dynamically typed language, it is hard to ensure completeness
of a \kw{match} statement, so completeness is not enforced; a mismatch is skipped
in much the same way a \kw{false} evaluation of an \kw{if} statement is skipped.

The \kw{match} statement takes an expression and is followed by multiple \kw{case}
statements. Each \kw{case} statement has a pattern, a guard, or both, and then a block
of code to run if that case is selected.

\begin{bnf*}
    \bnfprod{SMatch}{
        \bnfts{\kw{match}}
        \bnfsp
        \bnfpn{Expression}
        \bnfsp
        \bnfpn{Cases}
    } \\
    \bnfprod{Cases}{
        \bnfpn{Case}\bnfsp\bnfpn{Cases}\bnfor\bnfpn{Case}
    } \\
    \bnfprod{Case}{
        \bnfts{\kw{case}}
        \bnfsp
        \bnfpn{Pattern}
        \bnfsp
        \bnfpn{Block}
        \bnfor
    } \\
    \bnfmore{
        \bnfts{\kw{case}}
        \bnfsp
        \bnfpn{Pattern}
        \bnfsp
        \bnfts{\kw{if}}
        \bnfsp
        \bnfpn{Expression}
        \bnfsp
        \bnfpn{Block}
        \bnfor
    } \\
    \bnfmore{
        \bnfts{\kw{case}}
        \bnfsp
        \bnfts{\kw{if}}
        \bnfsp
        \bnfpn{Expression}
        \bnfsp
        \bnfpn{Block}
        \bnfor
    }
\end{bnf*}

To evaluate a \kw{match} statement, the original expression is evaluated, and compared
against the pattern of each \kw{case}; an omitted pattern is interpreted like an underscore
(\texttt{\_}) pattern, matching with any value.

Before committing to a \kw{case} with a matching pattern, the guard is evaluated, if any.
If the guard expression evaluates to \kw{true} (or there are no guards), the case is selected.
Identifiers bound in the pattern are in scope for this evaluation. Any value that is not \kw{true},
including non-Boolean values, are treated as \kw{false}, and the case is not selected. An omitted
guard is treated to be always \kw{true}.

The block following the first selected case is then run. If no cases are selected,
they are simply ignored and the program continues.

\begin{prooftree}
    \AxiomC{$\Gamma \vdash E$}
    \AxiomC{$P = E$}
    \AxiomC{$\Gamma,\{a\ |\ a := P\} \vdash C = \kw{true}$}
    \LeftLabel{Match}
    \TrinaryInfC{$\Gamma \vdash \kw{match}\ E\ \kw{case}\ P\ \kw{if}\ C\ B \Rightarrow \Phi$}
\end{prooftree}

\begin{prooftree}
    \def\extraVskip{3.5pt}
    \AxiomC{$\Gamma \vdash E$}
    \AxiomC{$P = E$}
    \AxiomC{$\Gamma,\{a\ |\ a := P\} \vdash C \neq \kw{true}$}
    \TrinaryInfC{$R_1 = \kw{case}\ P\ \kw{if}\ C\ B$}
    \AxiomC{$\Gamma \vdash \kw{match}\ E\ R_2 \cdots R_n \Rightarrow \Phi$}
    \LeftLabel{Match\textsuperscript{\kw{false}}}
    \insertBetweenHyps{\hskip -12pt}
    \BinaryInfC{$\Gamma \vdash \kw{match}\ R_1 R_2 \cdots R_n \Rightarrow \Phi$}
\end{prooftree}

\begin{prooftree}
    \def\extraVskip{3.5pt}
    \AxiomC{$\Gamma \vdash E$}
    \AxiomC{$P \neq E$}
    \BinaryInfC{$R_1 = \kw{case}\ P\ \kw{if}\ C\ B$}
    \AxiomC{$\Gamma \vdash \kw{match}\ E\ R_2 \cdots R_n \Rightarrow \Phi$}
    \LeftLabel{Match\textsuperscript{$\bot$}}
    \BinaryInfC{$\Gamma \vdash \kw{match}\ R_1 R_2 \cdots R_n \Rightarrow \Phi$}
\end{prooftree}

The omitted clauses of the \kw{case} statement are formalized by syntax transformation:

\begin{align*}
    \texttt{\kw{case} \$p:pat} &\Rightarrow \texttt{\kw{case} \$p \kw{if} \kw{true}} \\ %
    \texttt{\kw{case} \kw{if} \$c:expr} &\Rightarrow \texttt{\kw{case} \_ \kw{if} \$c} \\ %
\end{align*}

\subsubsection{While}

The \kw{while} loop accepts a Boolean condition and repeats a block of code
until that condition evaluates to \kw{false}. \Trilogy{}'s \kw{while} loop is
very standard, as far as such loops go. There is no \texttt{do}\dots\texttt{while}
loop in \Trilogy{}.

\begin{bnf*}
    \bnfprod{SWhile}{
        \bnfts{\kw{while}}
        \bnfsp
        \bnfpn{Expression}
        \bnfsp
        \bnfpn{Block}
    }
\end{bnf*}

Branching may occur in the body of a \kw{while} loop, leading to more iterations
than expected if not careful. However, since the \kw{while} loop provides no collection
mechanism, once those branches break out of the loop they will continue to execute
beyond the end of the loop.

\begin{prooftree}
    \AxiomC{$\Gamma\vdash C = \kw{true}$}
    \AxiomC{$\Gamma\vdash B \Rightarrow \Phi$}
    \AxiomC{$\Phi\vdash \kw{while}\ C\ B \Rightarrow\Sigma$}
    \LeftLabel{Loop}
    \TrinaryInfC{$\Gamma\vdash \kw{while}\ C\ B \Rightarrow \Sigma$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash C = \kw{false}$}
    \LeftLabel{End Loop}
    \UnaryInfC{$\Gamma\vdash \kw{while}\ C\ B:\top$}
\end{prooftree}

\subsubsection{For}

The \kw{for} loop accepts a pattern as a condition and repeats a block of code
for all valid bindings generated by that pattern. This is more similar to a for-each
loop than the three part conditional loop seen in some imperative languages.
No such conditional \kw{for} loop exists in \Trilogy{}, but similar semantics can
be constructed using \kw{while}.

\begin{bnf*}
    \bnfprod{SFor}{
        \bnfts{\kw{for}}
        \bnfsp
        \bnfpn{Unification}
        \bnfsp
        \bnfpn{Block}
    }
\end{bnf*}
