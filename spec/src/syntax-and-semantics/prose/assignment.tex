\subsubsection{Assignment}

Variables (specifically, mutable bindings) may be assigned to. Similar to
declaration via \kw{let}, the left-hand side of standard assignment may be
any pattern so long as it does not introduce new bindings. The pattern may only
use previously bound names. The assignment statement updates the values of the
bindings in the pattern.

The left-hand side may also be a member access expression (\S\ref{sec:member-access}),
in which case the member in the collection is updated in-place but otherwise the
assignment works as any other normal.

Function assignment is a special syntax for applying a function to a value and
then simultaneously reassigning that value with the result of the function; a
generalization of operator assignment (e.g. \op{+=}) to any function\footnote{A
generalization which I cannot take credit for as I was inspired to it by
\href{https://github.com/betaveros/noulith}{Noulith}, the same project
which inspired me to attempt \Trilogy{} at all.}. In this form
of assignment, the left-hand side of the assignment operator is a single identifier,
and the right side is the arguments to apply to the function being used as the
assignment operator. The left hand side is then applied as the last argument to
the function.

Regular operator assignment (\op{+=}, \op{-=}, etc.) is supported as well, in the
intuitive way: the left hand identifer is used as the left hand side of the operator.

\begin{bnf*}
    \bnfprod{SAssignment}{
        \bnfpn{Assignment}
        \bnfor
        \bnfpn{FunctionAssignment}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{OperatorAssignment}
    } \\
    \bnfprod{Assignment}{
        \bnfpn{LValue}
        \bnfsp
        \bnfts{\op{=}}
        \bnfsp
        \bnfpn{Expression}
    } \\
    \bnfprod{FunctionAssignment}{
        \bnfpn{LValue}
        \bnfsp
        \bnfts{IdentifierEq}
        \bnfsp
        \bnfpn{ApplicationList}
    } \\
    \bnfprod{OperatorAssignment}{
        \bnfpn{LValue}
        \bnfsp
        \bnfpn{OperatorEq}
        \bnfsp
        \bnfpn{Expression}
    } \\
    \bnfprod{LValue}{
        \bnfpn{Pattern}
        \bnfor
        \bnfpn{MemberAccess}
    } \\
    \bnfprod{OperatorEq}{
        \bnfts{+=}\bnfor
        \bnfts{-=}\bnfor
        \bnfts{*=}\bnfor
        \bnfts{/=}\bnfor
        \bnfts{\%=}\bnfor
        \bnfts{**=}\bnfor
        \bnfts{//=}\bnfor
        \bnfts{<>=}\bnfor
    } \\
    \bnfmore{
        \bnfts{|=}\bnfor
        \bnfts{\&=}\bnfor
        \bnfts{\textasciicircum=}\bnfor
        \bnfts{<\textasciitilde=}\bnfor
        \bnfts{\textasciitilde>=}\bnfor
        \bnfts{<<=}\bnfor
        \bnfts{>>=}
    }
\end{bnf*}

Semantically, the assignment statement evaluates its value and then updates
the binding in the current context. Assignment in this way is the only way
a binding in a scope is modified (other operations typically generate a new scope
that extends from the previous, introducing new bindings). In particular, the
update of the binding updates it in the scope that it was defined, not in the
latest extending scope, therefore making it possible to update the value of a
variable defined outside of a block such that the modification persists to be
seen outside of that block.

\begin{prooftree}
    \AxiomC{$\Gamma \vdash y$}
    \AxiomC{$P = y$}
    \AxiomC{$a \defby P$}
    \LeftLabel{Assignment}
    \TrinaryInfC{$\Gamma\vdash P\ \op{=}\ y \Rightarrow \Gamma[a\mapsto y]$}
\end{prooftree}

For a member access assignment, this update simply happens not just within
a scope but within the value itself as well.

\begin{prooftree}
    \AxiomC{$\Gamma\vdash v$}
    \AxiomC{$\Gamma\vdash E = x$}
    \AxiomC{$\Gamma\vdash y$}
    \LeftLabel{Assignment}
    \TrinaryInfC{$\Gamma\vdash v\ \texttt{.}\ E\ \op{=}\ y \Rightarrow \Gamma[v\mapsto v[x\mapsto y]]$}
\end{prooftree}

Rather than defining the exact semantics of function or operator assignment,
instead understand those by syntax transformation, and use the same assignment
semantics as normal:

\begin{align*}
    \texttt{\$x:id \$fn:id= \$(\$a:expr)+} &\Rightarrow \texttt{\$x = \$f \$(\$a)+ \$x} \\ %
    \texttt{\$x:id \$op:op= \$a:expr} & \Rightarrow \texttt{\$x = \$x \$op \$a} \\ %
\end{align*}
