\subsubsection{Procedure Calls}
\label{sec:prose-procedure-call}

As previously mentioned, procedure calls are permitted at the top level of
another procedure, as a statement. In this situation, the return value of
the procedure call is lost, but multiple evaluations may be created. Procedure
calls in statement position are also explicitly permitted to carry effect handlers.

Again, though the procedure call syntax includes the exclamation mark joined to the
name of the procedure before the argument list, this exclamation mark is not part
of the name of the procedure; it is only a piece of the definition and call syntax.

\begin{bnf*}
    \bnfprod{SProcedureCall}{
        \bnfpn{ProcedureCall}
        \bnfor
        \bnfpn{ProcedureCall}
        \bnfsp
        \bnfpn{EffectHandlers}
    } \\
    \bnfprod{ProcedureCall}{
        \bnfpn{PathBang}
        \bnfsp
        \bnfts{(}
        \bnfsp
        \bnfpn{ArgumentList}
        \bnfsp
        \bnfts{)}
    } \\
    \bnfprod{PathBang}{
        \bnfpn{ModuleReference}
        \bnfsp
        \bnfts{\op{.}}
        \bnfsp
        \bnfpn{Path}
        \bnfor
        \bnfpn{IdentifierBang}
    } \\
    \bnfprod{ArgumentList}{
        \bnfpn{Expr}
        \bnfsp
        \bnfts{,}
        \bnfsp
        \bnfpn{ArgumentList}
        \bnfor
        \bnfpn{Expr}
        \bnfor
        \bnfes
    }
\end{bnf*}

Semantically, a procedure call looks up an identifier in the current scope to
locate a procedure, and then supplies the provided arguments as the parameters
to the procedure. This is much the same as any function call in any other
imperative language.

\begin{prooftree}
    \AxiomC{$\Gamma\vdash p : \texttt{!}(x_{1\hdots n})\rightarrow\tau$}
    \AxiomC{$a_i = x_i$}
    \LeftLabel{Procedure Call}
    \BinaryInfC{$\Gamma\vdash p\texttt{!}(a_{1\hdots n}):\top$}
\end{prooftree}
