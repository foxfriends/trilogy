\section{Syntax and Semantics}
\label{sec:syntax}

As previously mentioned, grammars in this document are
\href{https://en.wikipedia.org/wiki/Parsing_expression_grammar}{PEGs},
albeit lacking in all syntax sugar.

In this section, terminals each refer to token types, though for tokens
with a single source text representation, their textual representation
is preferred for readability. The productions refer to nodes in the
abstract syntax tree, and are named as they are in the implementation
source code.

Between any two tokens may be any number of comment nodes. Additionally,
any whitespace (including line breaks) may occur between any two tokens
without issue. In certain marked cases, however, line breaks are required
as a statement terminator; in such cases, the line break is always interpreted
as a statement terminator, and not as meaningless whitespace.

The required end of line rule is formalized as follows:

\begin{bnf*}
    \bnfprod{EOL}{
        \bnfts{EndOfLine}\bnfor
        \bnfts{CommentLine}\bnfor
        \bnfts{CommentBlock}\bnfor
    } \\
    \bnfmore{
        \bnfts{DocInner}\bnfor
        \bnfts{DocOuter}
    }
\end{bnf*}

\subsection{Trilogy}

The top level of a \Trilogy{} file is the only part of the document that
is not written in one of the child languages. This section of the program
may only contain definitions.

\subsubsection{The Document}

A \Trilogy{} document \emph{should} end with a final line break,
but files without such a final line break may be accepted (with warning).
It is optional to implement rule~\ref{bnf:finaleol}.

As a notable exception, rule~\ref{bnf:empty} indicates that a truly empty
file \emph{is} accepted, regardless of the fact that it does not end with
a line break.

A byte order mark \emph{may} be accepted (with warning) at the start of
the file. It is optional to implement rule~\ref{bnf:bom}.

\begin{bnf}
    \bnfprod*{Document}{
        \bnfpn{Preamble}
        \bnfsp
        \bnfpn{Definitions}
        \bnfsp
        \bnfpn{Postamble}
        \bnfor
    } \\
    \bnfmore{\label{bnf:empty}\bnfpn{Preamble}\bnfsp\bnfts{EndOfFile}} \\
    \bnfprod*{Preamble}{\bnfts{StartOfFile}\bnfor} \\
    \bnfmore{
        \label{bnf:bom}
        \bnfts{StartOfFile}
        \bnfsp
        \bnfts{ByteOrderMark}
    } \\
    \bnfprod*{Postamble}{
        \bnfts{EOL}
        \bnfsp
        \bnfts{EndOfFile}
        \bnfor
    } \\
    \bnfmore{\label{bnf:finaleol}\bnfts{EndOfFile}} \\
    \bnfprod*{Definitions}{
        \bnfpn{Definition}\bnfsp\bnfpn{Definitions}\bnfor\bnfes
    } \\
    \bnfprod*{Definition}{
        \bnfpn{ModuleDefinition}\bnfor
        \bnfpn{ProcedureDefinition}\bnfor
    } \\
    \bnfmore*{
        \bnfpn{FunctionDefinition}\bnfor
        \bnfpn{RuleDefinition}\bnfor
    } \\
    \bnfmore*{\bnfpn{Import}\bnfor\bnfpn{Export}}
\end{bnf}

\subsubsection{Modules}

Modules act as containers for definitions, including procedures,
functions, rules, and further submodules. Every \Trilogy{} document is
implicitly a module, meaning a document may export any of its defined items,
to make them available to other modules that import that document. Any item
defined at the top level of a module may be exported: procedures, functions,
rules, modules, and imported items.

The \Trilogy{} module system is modelled after that of OCaml: modules may
be defined as functions which accept one or more other modules as parameters,
and generate a new module. As in OCaml, such modules functions are \emph{applicative}:
if a module function is applied to the same arguments multiple times, it will
generate the same resulting module. At this time, a document cannot specify
parameters, so such function modules may only be defined as a local submodule
within some existing module.

Modules defined as external modules via the \kw{module}-\kw{at} construct
\todo{Define and link module resolution algorithm.}
are resolved as documents located via the canonical absolute URL designated
by the (potentially relative) path \texttt{String} in rule~\ref{bnf:module-at}.
If two external module definitions paths resolve to the same canonical absolute
URL, those two modules will be considered identical, despite being ``defined''
in two places in the source code. The full details of the path resolution
algorithm are defined later.

\begin{bnf}
    \bnfprod{ModuleDefinition}{
        \label{bnf:module-at}
        \bnfts{\kw{module}}
        \bnfsp
        \bnfts{Identifier}
        \bnfsp
        \bnfts{\kw{at}}
        \bnfsp
        \bnfts{String}
        \bnfor
    } \\
    \bnfmore*{\bnfts{\kw{module}}\bnfsp\bnfts{\{}\bnfsp\bnfpn{Definitions}\bnfsp\bnfts{\}}\bnfor} \\
    \bnfmore*{\bnfts{\kw{module}}\bnfsp\bnfts{(}\bnfsp\bnfpn{ModuleParameters}\bnfsp\bnfts{)}\bnfsp\bnfts{\{}\bnfsp\bnfpn{Definitions}\bnfsp\bnfts{\}}} \\
    \bnfprod*{ModuleParameters}{\bnfts{Identifier}\bnfsp\bnfts{,}\bnfsp\bnfpn{ModuleParameters}\bnfor} \\
    \bnfmore*{\bnfts{Identifier}\bnfor\bnfes} \\
    \bnfprod*{Import}{
        \bnfts{\kw{import}}
        \bnfsp
        \bnfpn{ModuleReference}
        \bnfsp
        \bnfts{\kw{as}}
        \bnfsp
        \bnfts{Identifier}
        \bnfor
    } \\
    \bnfmore*{
        \bnfts{\kw{import}}
        \bnfsp
        \bnfpn{ImportList}
        \bnfsp
        \bnfts{\kw{from}}
        \bnfsp
        \bnfpn{ModuleReference}
    } \\
    \bnfprod*{ImportList}{
        \bnfts{Identifier}
        \bnfsp
        \bnfts{,}
        \bnfsp
        \bnfpn{ImportList}
        \bnfor
    } \\
    \bnfmore*{
        \bnfts{IdentifierBang}
        \bnfsp
        \bnfts{,}
        \bnfsp
        \bnfpn{ImportList}
        \bnfor
    } \\
    \bnfmore*{
        \bnfts{Identifier}
        \bnfor
        \bnfts{IdentifierBang}
        \bnfor
        \bnfes
    } \\
    \bnfprod*{ModuleReference}{
        \bnfts{Identifier}
        \bnfor
        \bnfts{Identifier}
        \bnfsp
        \bnfts{(}
        \bnfsp
        \bnfpn{ModuleArguments}
        \bnfsp
        \bnfts{)}
    } \\
    \bnfprod*{ModuleArguments}{
        \bnfts{ModuleReference}
        \bnfsp
        \bnfts{,}
        \bnfsp
        \bnfpn{ModuleArguments}
        \bnfor
    } \\
    \bnfmore*{
        \bnfts{ModuleReference}
        \bnfor
        \bnfes
    }
\end{bnf}

A \kw{module} definition puts into scope a namespace in which all
\kw{export}ed definitions contained within the module may be accessed.
An \kw{import} may be used to bring specific items from such a namespace
into scope, or to rename a module something more convenient.

When a module is defined locally (directly in the same file as its parent
module), the definitions within the module may access all definitions (including
private definitions) of the containing module. The reverse is not true; the
private members of a submodule remain private unless exported.

\begin{prooftree}
    \def\defaultHypSeparation{\hskip 0in}
    \AxiomC{$\Gamma,m_{1\hdots n},\Phi \vdash p : \tau$}
    \AxiomC{$\kw{module}\ m\ (m_{1\hdots n})\ \{\ K\ \}$}
    \AxiomC{$K \Rightarrow \kw{export}\ p$}
    \LeftLabel{Local Module}
    \TrinaryInfC{$\Gamma \vdash m\texttt{.}p : \tau$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Phi \vdash p : \tau$}
    \AxiomC{$\kw{module}\ m\ \kw{at}\ \sigma$}
    \AxiomC{$\text{read}(\sigma) \Rightarrow \kw{export}\ p$ }
    \LeftLabel{External Module}
    \TrinaryInfC{$\Gamma \vdash m\texttt{.}p : \tau$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash m.p : \tau$}
    \AxiomC{$\kw{import}\ m\ \kw{as}\ n$}
    \LeftLabel{Import As}
    \BinaryInfC{$\Gamma \vdash n\texttt{.}p : \tau$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash m.p : \tau$}
    \AxiomC{$\kw{import}\ p\ \kw{from}\ m$}
    \LeftLabel{Import From}
    \BinaryInfC{$\Gamma \vdash p : \tau$}
\end{prooftree}

\subsubsection{Definitions}

The other types of definitions each hand off to their respective child
languages.

\begin{bnf*}
    \bnfprod{ProcedureDefinition}{
        \bnfts{\kw{proc}}
        \bnfsp
        \bnfpn{ProcedureHead}
        \bnfsp
        \bnfts{\{}
        \bnfsp
        \bnfpn{ProcedureBody}
        \bnfsp
        \bnfts{\}}
    } \\
    \bnfprod{FunctionDefinition}{
        \bnfts{\kw{func}}
        \bnfsp
        \bnfpn{FunctionHead}
        \bnfsp
        \bnfts{=}
        \bnfsp
        \bnfpn{FunctionBody}
    } \\
    \bnfprod{RuleDefinition}{\bnfts{\kw{rule}}\bnfsp\bnfpn{RuleHead}\bnfor} \\
    \bnfmore{\bnfts{\kw{rule}}\bnfsp\bnfpn{RuleHead}\bnfsp{\op{:-}}\bnfsp\bnfpn{RuleBody}}
\end{bnf*}

\subimport{data/}{index.tex}

\subimport{prose/}{index.tex}
