\subsection{Poetry}

As \Law{} is a language of binding, and \Prose{} a language of control
flow, \Poetry{} is a language of value. As a pure functional programming
language, \Poetry{} is highly expression-based, though given the existence
of the effect system it is possible to trigger side effects, in a way.

\begin{bnf*}
    \bnfprod{FunctionHead}{
        \bnfpn{Identifier}
        \bnfsp
        \bnfpn{ParameterList}
        \bnfor
    } \\
    \bnfmore{
        \bnfpn{Identifier}
        \bnfsp
        \bnfpn{ParameterList}
        \bnfsp
        \bnfts{\kw{if}}
        \bnfsp
        \bnfpn{Expression}
    } \\
    \bnfprod{ParameterList}{
        \bnfpn{Pattern}
        \bnfsp
        \bnfpn{ParameterList}
        \bnfor
        \bnfpn{Pattern}
    } \\
    \bnfprod{FunctionBody}{\bnfpn{Expression}}
\end{bnf*}

Similar to Haskell, functions in \Poetry{} are defined as equations. Defining
the same name multiple times is allowed, given that its number of arguments
is the same, and the patterns of its parameters are changed, allowing different
cases of a function to be handled by different expressions. When the function is
applied, the first matching definition in source code order is used, and the
others are skipped.

Also similar to Haskell, functions support currying and partial application by
default. In \Trilogy{}, this is defined as a syntax transformation over function
definitions with multiple parameters into unary functions returning a function
that accepts the next parameter.

A function definition may optionally include a guard expression, following the
\kw{if} keyword. In this situation, the guard is evaluated after matching the
parameters with their provided values, and if the guard evaluates to false, the
overload is skipped as if the head did not match.

Unsimilarly to Haskell, \Poetry{} is evaluated eagerly. This means that nullary
(0-argument) functions would be pretty useless, so all functions \emph{must} have a
parameter. Nullary procedures may be a simple alternative, where the calling of that
procedure is explicit.

\begin{align*}
    \texttt{\$f:id \$(\$r:pat)+ \$p:pat = \$e:expr} & \Rightarrow \texttt{\$f \$(\$r)+ = \kw{fn} \$p. \$e} %
\end{align*}

\begin{prooftree}
    \def\defaultHypSeparation{\hskip 0.1in}
    \AxiomC{$\kw{func}\ f\ P\ \texttt{=}\ E$}
    \AxiomC{$\Sigma\vdash X : \tau$}
    \AxiomC{$P = X$}
    \AxiomC{$\Gamma,\setof{a\given a\defby P}\vdash E : \rho $}
    \LeftLabel{Function}
    \QuaternaryInfC{$\Gamma\vdash f : \tau \rightarrow \rho$}
\end{prooftree}

\begin{prooftree}
    \def\defaultHypSeparation{\hskip 0.1in}
    \AxiomC{$\kw{func}\ f\ P\ \kw{if} \ G\ \texttt{=}\ E$}
    \AxiomC{$\Sigma\vdash X : \tau$}
    \AxiomC{$P = X$}
    \noLine
    \insertBetweenHyps{\qquad\qquad}
    \TrinaryInfC{$\Gamma,\setof{a\given a\defby P}\vdash E : \rho \qquad \Gamma,\setof{a\given a\defby P}\vdash G = \kw{true}$}
    \LeftLabel{Guarded Function}
    \UnaryInfC{$\Gamma\vdash f : \tau \rightarrow \rho$}
\end{prooftree}

\input{expressions.tex}

\input{literal.tex}

\input{comprehension.tex}

\input{reference.tex}

\input{module-access.tex}

\input{application.tex}

\input{procedure-call.tex}

\input{binary-op.tex}

\input{member-access.tex}

\input{unary-op.tex}

\input{let.tex}

\input{ifelse.tex}

\input{match.tex}

\input{is.tex}

\input{end.tex}

\input{exit.tex}

\input{closures.tex}

\input{for.tex}

\input{first-class-keyword.tex}

\input{handled.tex}

\input{template.tex}

\input{precedence.tex}
