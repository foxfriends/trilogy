\subsubsection{Reference}

Defined names may be referenced at any time, their naming evaluating to the value
they currently hold. This is a typical variable reference as in any language.
Notably this is \emph{only} for variable references, looking up a name in another
scope is handled by the member access.

As a bit of a special case, the built-in operators may be referenced as if they
were functions by wrapping them in parentheses. This allows operators to be passed
as values and applied as if they were functions to their arguments, occasionally
useful in some functional compositions. The operators themselves are specified
in \S\ref{sec:unaryop} and \S\ref{sec:binop}

\begin{bnf*}
    \bnfprod{Reference}{
        \bnfpn{Identifier}
        \bnfor
        \bnfts{(}
        \bnfsp
        \bnfpn{UnaryOperator}
        \bnfsp
        \bnfts{)}
        \bnfor
        \bnfts{(}
        \bnfsp
        \bnfpn{BinaryOperator}
        \bnfsp
        \bnfts{)}
    }
\end{bnf*}

Admittedly the following semantics look a little wonky due to an ambiguous choice
of notation. Rest assured, in the hypotheses the $x$ refers to the binding in the
context, while in the inference the $x$ refers to the symbol in source code, so
this is not an infinitely recursive deduction.

\begin{prooftree}
    \AxiomC{$\Gamma\vdash x : \tau$}
    \LeftLabel{Reference}
    \UnaryInfC{$\Gamma\vdash x : \tau$}
\end{prooftree}

% TODO: for completeness, include semantics of each parenthesized operator? Or
% is that just a pain...
