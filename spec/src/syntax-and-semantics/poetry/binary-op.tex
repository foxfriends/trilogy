\subsubsection{Binary Operation}
\label{sec:binop}

Binary operators in \Poetry{} are infix operators, and are always written
with both arguments. As previously mentioned, operator precedence is not
handled by the syntax tree but by another pass afterwards.

\begin{bnf*}
    \bnfprod{BinaryOp}{
        \bnfpn{Expression}
        \bnfsp
        \bnfpn{BinaryOperator}
        \bnfsp
        \bnfpn{Expression}
    } \\
    \bnfprod{BinaryOperator}{
        \bnfts{\kw{and}}
        \bnfor
        \bnfts{\kw{or}}
        \bnfor
        \bnfts{\op{+}}
        \bnfor
        \bnfts{\op{-}}
        \bnfor
        \bnfts{\op{*}}
        \bnfor
        \bnfts{\op{/}}
        \bnfor
        \bnfts{\op{\%}}
        \bnfor
        \bnfts{\op{**}}
        \bnfor
        \bnfts{\op{//}}
        \bnfor
    } \\
    \bnfmore{
        \bnfts{\op{==}}
        \bnfor
        \bnfts{\op{===}}
        \bnfor
        \bnfts{\op{<}}
        \bnfor
        \bnfts{\op{>}}
        \bnfor
        \bnfts{\op{>=}}
        \bnfor
        \bnfts{\op{<=}}
        \bnfor
    } \\
    \bnfmore{
        \bnfts{\op{\&}}
        \bnfor
        \bnfts{\op{|}}
        \bnfor
        \bnfts{\op{\textasciicircum}}
        \bnfor
        \bnfts{\op{<\textasciitilde}}
        \bnfor
        \bnfts{\op{\textasciitilde>}}
        \bnfor
        \bnfts{\op{,}}
        \bnfor
        \bnfts{\op{:}}
        \bnfor
    } \\
    \bnfmore{
        \bnfts{\op{<>}}
        \bnfor
        \bnfts{\op{>>}}
        \bnfor
        \bnfts{\op{<<}}
        \bnfor
        \bnfts{\op{|>}}
        \bnfor
        \bnfts{\op{<|}}
    } \\
\end{bnf*}

Now comes the long and tedious process of defining each of these operators.
Worst part is that I know you know how these operators are supposed to work,
they're all the regular old stuff we see in every other language, but since
we are working with the primitive types, there's nothing we can do but to
define these things as internal magic, and so I guess it does require
specification somewhere.

Starting with the Boolean operators \kw{and} and \kw{or}, these are the typical
ones with behaviour that hardly needs explaining, and are short circuiting. If
one of the operands to either of these operators is evaluated and does not result
in a Boolean value, this is a runtime type error (if it does not get evaluated
due to short circuiting, the type error never happens).

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = \kw{false}$}
    \LeftLabel{And}
    \UnaryInfC{$\Gamma\vdash A\ \kw{and}\ B = \kw{false}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = \kw{true}$}
    \AxiomC{$\Gamma\vdash B = \kw{false}$}
    \LeftLabel{And}
    \BinaryInfC{$\Gamma\vdash A\ \kw{and}\ B = \kw{false}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = \kw{true}$}
    \AxiomC{$\Gamma\vdash B = \kw{true}$}
    \LeftLabel{And}
    \BinaryInfC{$\Gamma\vdash A\ \kw{and}\ B = \kw{true}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = \kw{true}$}
    \LeftLabel{Or}
    \UnaryInfC{$\Gamma\vdash A\ \kw{or}\ B = \kw{true}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = \kw{false}$}
    \AxiomC{$\Gamma\vdash B = \kw{true}$}
    \LeftLabel{Or}
    \BinaryInfC{$\Gamma\vdash A\ \kw{or}\ B = \kw{true}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = \kw{false}$}
    \AxiomC{$\Gamma\vdash B = \kw{false}$}
    \LeftLabel{Or}
    \BinaryInfC{$\Gamma\vdash A\ \kw{or}\ B = \kw{false}$}
\end{prooftree}

The mathematical operators are next, and as you might expect they work
as expected. Some details are worth noting however.

The mathematical operators work on values of Number type, if either operand
is not a Number, it causes a runtime type error.

Though we are strict about that, division by zero is not an error but instead
yields the exceptional result \val{'INF}. I am aware that division by zero is
explicitly defined as undefined, and is very definitely not mathematically
infinity, but \val{'INF} is not infinity, it is simply a signal that division
by zero was performed. This is the case for both regular divison (\op{/}) and
integer division (\op{//}), which floors to the nearest integer after dividing.

The \op{\%} operator is the remainder operator, returning the remainder of
integer division. Notably the remainder operator is the integer remainder operator,
not a modulus operator, and is implemented following the same floored division
as with integer division.

The \op{**} operator is the exponentiation operator and, given the fact that
precise rationals are available in \Trilogy{}, it also can be used for computing
square roots and such when given a fractional power. Since \Trilogy{} also
supports complex numbers, the result of something such as \texttt{-1 ** 1/2}
will not be an error, but actually the complex number \val{0i1}.

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Number}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Number}$}
    \LeftLabel{Addition}
    \BinaryInfC{$\Gamma\vdash A\ \op{+}\ B = a + b : \ty{Number}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Number}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Number}$}
    \LeftLabel{Subtraction}
    \BinaryInfC{$\Gamma\vdash A\ \op{-}\ B = a - b : \ty{Number}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Number}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Number}$}
    \LeftLabel{Multiplication}
    \BinaryInfC{$\Gamma\vdash A\ \op{*}\ B = a \times b : \ty{Number}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Number}$}
    \AxiomC{$\Gamma\vdash B = 0$}
    \LeftLabel{Division}
    \BinaryInfC{$\Gamma\vdash A\ \op{/}\ B \vartriangle \val{'INF}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Number}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Number}$}
    \LeftLabel{Division}
    \BinaryInfC{$\Gamma\vdash A\ \op{/}\ B = a \div b : \ty{Number}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Number}$}
    \AxiomC{$\Gamma\vdash B = 0$}
    \LeftLabel{Integer Division}
    \BinaryInfC{$\Gamma\vdash A\ \op{//}\ B \vartriangle \val{'INF}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Number}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Number}$}
    \LeftLabel{Integer Division}
    \BinaryInfC{$\Gamma\vdash A\ \op{//}\ B = \lfloor a \div b \rfloor : \ty{Number}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Number}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Number}$}
    \LeftLabel{Remainder}
    \BinaryInfC{$\Gamma\vdash A\ \op{\%}\ B = a - b \lfloor a \div b \rfloor : \ty{Number}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Number}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Number}$}
    \LeftLabel{Exponentiation}
    \BinaryInfC{$\Gamma\vdash A\ \op{**}\ B = a^b : \ty{Number}$}
\end{prooftree}

Comparison operators compare two values and returns a Boolean result depending
on the result of the comparison.

The structural equality operator (\op{==}) compares values of structural type
(\S\ref{sec:structuraltypes}), returning \kw{true} if they are the same value,
and \kw{false} otherwise. Non-structural types are compared by reference
instead, only an exact reference evaluating to \kw{true}. This turns out to
be much like a Boolean valuation of a direct unification, only without option
of comparing two incomplete patterns.

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A$}
    \AxiomC{$\Gamma\vdash B$}
    \AxiomC{$\Gamma\vdash A = B$}
    \LeftLabel{Structural Equality}
    \TrinaryInfC{$\Gamma\vdash A\ \op{==}\ B = \kw{true}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A$}
    \AxiomC{$\Gamma\vdash B$}
    \AxiomC{$\Gamma\vdash A \neq B$}
    \LeftLabel{Structural Equality}
    \TrinaryInfC{$\Gamma\vdash A\ \op{==}\ B = \kw{false}$}
\end{prooftree}

The referential equality operator (\op{===}) compares values of reference type
(\S\ref{sec:referencetypes}), returning \kw{true} if they are the same instance,
and \kw{false} otherwise. Non-reference types are compared structurally instead.
This operator is of a more practical sort, hooking in to implementation detail
rather than logical or mathematical purity.

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A$}
    \AxiomC{$\Gamma\vdash B$}
    \AxiomC{$\Gamma\vdash \text{addr}(A) = \text{addr}(B)$}
    \LeftLabel{Reference Equality}
    \TrinaryInfC{$\Gamma\vdash A\ \op{===}\ B = \kw{true}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A$}
    \AxiomC{$\Gamma\vdash B$}
    \AxiomC{$\Gamma\vdash \text{addr}(A) \neq \text{addr}(B)$}
    \LeftLabel{Reference Equality}
    \TrinaryInfC{$\Gamma\vdash A\ \op{===}\ B = \kw{false}$}
\end{prooftree}

The ordered comparison operators work on any two values of the same type. Not
all types are orderable, however, in which case the comparison returns \kw{unit}
to indicate that an order cannot be determined. This \kw{unit} result is distinct
from indicating that two compared items are the ``same'' in magnitude. When used
on two values of different types, they are treated as unorderable and the comparison
again returns \kw{unit}. This is different from most other type-mismatches in \Trilogy{},
which cause a runtime type error; where those situations have no clear path forward,
the ``unorderable'' option in this case is more flexible and does not make any
assumptions about the behaviour of a program.

Rather than defining the proof trees for every comparable type, this table summarizes
orderings, and is referred to as $\text{cmp}(A \square B)$ in the proof trees below. Note
that in lexicographical order, elements are compared before the lengths of the sequences;
if one value is a prefix of the other, the prefix value is less than the longer value.
In the fallible lexicographical order, if any element-wise comparison is unorderable, the
whole result is treated unorderable.

\begin{table}[H]
    \centering
    \begin{tabular}{ll}
        \hline
        \textbf{Type}          & \textbf{Ordering} \\
        \hline
        Unit                   & Unorderable \\
        Atom                   & Unorderable \\
        Boolean                & \kw{false} then \kw{true} \\
        Real Number            & Number line ordering \\
        Imaginary Number       & Magnitude ordering \\
        Complex Number         & Unorderable \\
        Character              & Unicode code point order \\
        String                 & Lexicographical order of characters \\
        Struct (same tag)      & Ordered by wrapped value order \\
        Struct (different tag) & Unorderable \\
        Bits                   & Ordered by big-endian integer interpretation \\
        Tuple                  & Compare left elements, then right elements \\
        Array                  & Fallible lexicographical order of elements \\
        Set                    & Unorderable\footnotemark[1] \\
        Record                 & Unorderable\footnotemark[1] \\
        Iterator               & Unorderable \\
        Semantic types         & Unorderable \\
        Mismatched types       & Unorderable \\
        \hline
    \end{tabular}
\end{table}

\footnotetext[1]{May be added at a later date, if a reasonable ordering is
determined and found to be useful.}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A$}
    \AxiomC{$\Gamma\vdash B$}
    \LeftLabel{Less Than}
    \BinaryInfC{$\Gamma\vdash A\ \op{<}\ B = \text{cmp}(A < B)$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A$}
    \AxiomC{$\Gamma\vdash B$}
    \LeftLabel{Greater Than}
    \BinaryInfC{$\Gamma\vdash A\ \op{>}\ B = \text{cmp}(A > B)$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A$}
    \AxiomC{$\Gamma\vdash B$}
    \LeftLabel{Less Than Or Equal To}
    \BinaryInfC{$\Gamma\vdash A\ \op{<=}\ B = \text{cmp}(A \leq B)$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A$}
    \AxiomC{$\Gamma\vdash B$}
    \LeftLabel{Greater Than Or Equal To}
    \BinaryInfC{$\Gamma\vdash A\ \op{>=}\ B = \text{cmp}(A \geq B)$}
\end{prooftree}

The bitwise operators work only on values of Bits type, with the exception
of the shift operators which expect the right-hand operand to be an integer.
Again, if the types are incorrect, it causes is a runtime type error.

The regular bitwise operators extend the shorter operand with 0s on the left
until both are of the same length. The left shift will extend with 0s on the
right, while the right shift removes bits from the right (no bits are added).

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Bits}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Bits}$}
    \LeftLabel{Bitwise And}
    \BinaryInfC{$\Gamma\vdash A\ \op{\&}\ B = a \land b$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Bits}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Bits}$}
    \LeftLabel{Bitwise Or}
    \BinaryInfC{$\Gamma\vdash A\ \op{|}\ B = a \lor b$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Bits}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Bits}$}
    \LeftLabel{Bitwise Xor}
    \BinaryInfC{$\Gamma\vdash A\ \op{|}\ B = a \oplus b$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = a : \ty{Bits}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Integer}$}
    \LeftLabel{Left Shift}
    \BinaryInfC{$\Gamma\vdash A\ \op{<\textasciitilde}\ B = a(b\cdot \texttt{0})$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma\vdash A = \rho \sigma : \ty{Bits}$}
    \AxiomC{$\Gamma\vdash B = b : \ty{Integer}$}
    \AxiomC{$|\sigma| = b$}
    \LeftLabel{Right Shift}
    \TrinaryInfC{$\Gamma\vdash A\ \op{\textasciitilde>}\ B = \rho$}
\end{prooftree}
